Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSERT
    BIN_NUMBER
    BITWISE_NOT
    BREAK
    BYTE_NUMBER
    CASE
    CATCH
    CHAR
    CONST
    CONTINUE
    DEFAULT
    DOT
    ENUM
    FINALLY
    GOTO
    HEXA_NUMBER
    IMPORT
    INSTANCEOF
    INTERFACE
    LONG_NUMBER
    NATIVE
    OCTAL_NUMBER
    POT
    SHORT
    STRICTFP
    SUPER
    SWITCH
    SYNCHRONIZED
    TERNARY
    THIS
    THROW
    THROWS
    TRANSIENT
    TRY
    VOLATILE

Grammar

Rule 0     S' -> program
Rule 1     program -> class
Rule 2     class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
Rule 3     class -> visibility classmodifier CLASS ID LCHAV membros RCHAV
Rule 4     class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
Rule 5     visibility -> PUBLIC
Rule 6     visibility -> PRIVATE
Rule 7     visibility -> PROTECTED
Rule 8     visibility -> <empty>
Rule 9     classmodifier -> <empty>
Rule 10    classmodifier -> ABSTRACT
Rule 11    classmodifier -> FINAL
Rule 12    classmodifier -> PACKAGE
Rule 13    classmodifier -> STATIC
Rule 14    classmodifier -> VOID
Rule 15    membros -> membro
Rule 16    membros -> membro membros
Rule 17    membro -> atribute
Rule 18    membro -> function
Rule 19    atribute -> visibility atributemodifier type ID SEMICOLON
Rule 20    atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON
Rule 21    atributemodifier -> <empty>
Rule 22    atributemodifier -> STATIC
Rule 23    atributemodifier -> FINAL
Rule 24    function -> signature body
Rule 25    signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN
Rule 26    signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
Rule 27    sigparams -> type ID
Rule 28    sigparams -> type ID COMMA sigparams
Rule 29    body -> LCHAV stms RCHAV
Rule 30    stms -> stm
Rule 31    stms -> stm stms
Rule 32    stm -> expression SEMICOLON
Rule 33    stm -> WHILE LPAREN expression RPAREN bodyorstm
Rule 34    stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
Rule 35    stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
Rule 36    stm -> IF LPAREN expression RPAREN bodyorstm
Rule 37    stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
Rule 38    stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
Rule 39    stm -> SEMICOLON
Rule 40    stm -> atributemodifier type ID SEMICOLON
Rule 41    stm -> atributemodifier type ID EQUAL expression SEMICOLON
Rule 42    stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON
Rule 43    stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON
Rule 44    stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
Rule 45    stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
Rule 46    stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
Rule 47    stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
Rule 48    stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
Rule 49    stm -> RETURN expression SEMICOLON
Rule 50    stm -> RETURN SEMICOLON
Rule 51    bodyorstm -> body
Rule 52    expression_for -> type ID EQUAL expression
Rule 53    expression_for -> ID EQUAL expression
Rule 54    expression -> operator
Rule 55    expression -> call
Rule 56    expression -> FLOAT_NUMBER
Rule 57    expression -> DOUBLE_NUMBER
Rule 58    expression -> INT_NUMBER
Rule 59    expression -> STRING
Rule 60    expression -> ID
Rule 61    expression -> NEW type LPAREN params_call RPAREN
Rule 62    expression -> NEW type LBRACKET expression RBRACKET
Rule 63    operator -> expression TIMES expression
Rule 64    operator -> expression DIVIDE expression
Rule 65    operator -> expression MODULE expression
Rule 66    operator -> expression PLUS expression
Rule 67    operator -> expression MINUS expression
Rule 68    operator -> ID EQUAL expression
Rule 69    operator -> ID MINUS_EQ expression
Rule 70    operator -> ID TIMES_EQ expression
Rule 71    operator -> ID PLUS_EQ expression
Rule 72    operator -> ID DIVIDE_EQ expression
Rule 73    operator -> ID MOD_EQ expression
Rule 74    operator -> ID BITWISE_AND_EQ expression
Rule 75    operator -> ID BITWISE_OR_EQ expression
Rule 76    operator -> ID BITWISE_XOR_EQ expression
Rule 77    operator -> ID URSHIFT_EQ expression
Rule 78    operator -> ID LSHIFT_EQ expression
Rule 79    operator -> ID RSHIFT_EQ expression
Rule 80    operator -> expression LEQ expression
Rule 81    operator -> expression GEQ expression
Rule 82    operator -> expression LT expression
Rule 83    operator -> expression GT expression
Rule 84    operator -> expression NEQ expression
Rule 85    operator -> expression EQ expression
Rule 86    operator -> expression AND expression
Rule 87    operator -> expression OR expression
Rule 88    operator -> expression BITWISE_AND expression
Rule 89    operator -> expression BITWISE_OR expression
Rule 90    operator -> expression BITWISE_XOR expression
Rule 91    operator -> unaryoperatorprefx ID
Rule 92    operator -> ID unaryoperatorsufx
Rule 93    operator -> expression operatorbittobit
Rule 94    unaryoperatorprefx -> INCREMENT
Rule 95    unaryoperatorprefx -> DECREMENT
Rule 96    unaryoperatorprefx -> MINUS
Rule 97    unaryoperatorprefx -> PLUS
Rule 98    unaryoperatorprefx -> NOT
Rule 99    unaryoperatorsufx -> INCREMENT
Rule 100   unaryoperatorsufx -> DECREMENT
Rule 101   operatorbittobit -> URSHIFT
Rule 102   operatorbittobit -> LSHIFT
Rule 103   operatorbittobit -> RSHIFT
Rule 104   brackets_expression -> LBRACKET RBRACKET
Rule 105   brackets_expression -> LBRACKET INT_NUMBER RBRACKET
Rule 106   brackets_expression -> LBRACKET ID RBRACKET
Rule 107   type -> primitivetypes
Rule 108   primitivetypes -> TYPE_INT
Rule 109   primitivetypes -> TYPE_FLOAT
Rule 110   primitivetypes -> TYPE_DOUBLE
Rule 111   primitivetypes -> TYPE_BYTE
Rule 112   primitivetypes -> TYPE_BOOLEAN
Rule 113   primitivetypes -> TYPE_CHAR
Rule 114   primitivetypes -> TYPE_STRING
Rule 115   primitivetypes -> TYPE_LONG
Rule 116   primitivetypes -> TYPE_VOID
Rule 117   call -> ID LPAREN params_call RPAREN
Rule 118   call -> ID LPAREN RPAREN
Rule 119   params_call -> expression COMMA params_call
Rule 120   params_call -> expression
Rule 121   chav_exp -> LCHAV RCHAV
Rule 122   chav_exp -> LCHAV expression_chav
Rule 123   expression_chav -> expression COMMA expression_chav
Rule 124   expression_chav -> expression RCHAV
Rule 125   expression_chav -> expression COMMA RCHAV

Terminals, with rules where they appear

ABSTRACT             : 10
AND                  : 86
ASSERT               : 
BIN_NUMBER           : 
BITWISE_AND          : 88
BITWISE_AND_EQ       : 74
BITWISE_NOT          : 
BITWISE_OR           : 89
BITWISE_OR_EQ        : 75
BITWISE_XOR          : 90
BITWISE_XOR_EQ       : 76
BREAK                : 
BYTE_NUMBER          : 
CASE                 : 
CATCH                : 
CHAR                 : 
CLASS                : 2 3 4
COMMA                : 28 119 123 125
CONST                : 
CONTINUE             : 
DECREMENT            : 95 100
DEFAULT              : 
DIVIDE               : 64
DIVIDE_EQ            : 72
DO                   : 34
DOT                  : 
DOUBLE_NUMBER        : 57
ELSE                 : 37 38
ENUM                 : 
EQ                   : 85
EQUAL                : 20 41 44 45 46 48 52 53 68
EXTENDS              : 2
FINAL                : 11 23
FINALLY              : 
FLOAT_NUMBER         : 56
FOR                  : 35
GEQ                  : 81
GOTO                 : 
GT                   : 83
HEXA_NUMBER          : 
ID                   : 2 2 3 4 19 20 25 26 27 28 40 41 42 43 44 45 46 47 48 52 53 60 68 69 70 71 72 73 74 75 76 77 78 79 91 92 106 117 118
IF                   : 36 37 38 38
IMPLEMENTS           : 4
IMPORT               : 
INCREMENT            : 94 99
INSTANCEOF           : 
INTERFACE            : 
INT_NUMBER           : 58 105
LBRACKET             : 42 43 44 45 46 47 47 48 48 62 104 105 106
LCHAV                : 2 3 4 29 121 122
LEQ                  : 80
LONG_NUMBER          : 
LPAREN               : 25 26 33 34 35 36 37 38 61 117 118
LSHIFT               : 102
LSHIFT_EQ            : 78
LT                   : 82
MINUS                : 67 96
MINUS_EQ             : 69
MODULE               : 65
MOD_EQ               : 73
NATIVE               : 
NEQ                  : 84
NEW                  : 61 62
NOT                  : 98
OCTAL_NUMBER         : 
OR                   : 87
PACKAGE              : 12
PLUS                 : 66 97
PLUS_EQ              : 71
POT                  : 
PRIVATE              : 6
PROTECTED            : 7
PUBLIC               : 5
RBRACKET             : 42 43 44 45 46 47 47 48 48 62 104 105 106
RCHAV                : 2 3 4 29 121 124 125
RETURN               : 49 50
RPAREN               : 25 26 33 34 35 36 37 38 61 117 118
RSHIFT               : 103
RSHIFT_EQ            : 79
SEMICOLON            : 19 20 32 34 35 35 39 40 41 42 43 44 45 46 47 48 49 50
SHORT                : 
STATIC               : 13 22
STRICTFP             : 
STRING               : 59
SUPER                : 
SWITCH               : 
SYNCHRONIZED         : 
TERNARY              : 
THIS                 : 
THROW                : 
THROWS               : 
TIMES                : 63
TIMES_EQ             : 70
TRANSIENT            : 
TRY                  : 
TYPE_BOOLEAN         : 112
TYPE_BYTE            : 111
TYPE_CHAR            : 113
TYPE_DOUBLE          : 110
TYPE_FLOAT           : 109
TYPE_INT             : 108
TYPE_LONG            : 115
TYPE_STRING          : 114
TYPE_VOID            : 116
URSHIFT              : 101
URSHIFT_EQ           : 77
VOID                 : 14
VOLATILE             : 
WHILE                : 33 34
error                : 

Nonterminals, with rules where they appear

atribute             : 17
atributemodifier     : 19 20 25 26 40 41 42 43 44 45 46 47 48
body                 : 24 51
bodyorstm            : 33 34 35 36 37 37 38 38
brackets_expression  : 26
call                 : 55
chav_exp             : 44 46 48
class                : 1
classmodifier        : 2 3 4
expression           : 20 32 33 34 35 35 36 37 38 41 45 49 52 53 62 63 63 64 64 65 65 66 66 67 67 68 69 70 71 72 73 74 75 76 77 78 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 93 119 120 123 124 125
expression_chav      : 122 123
expression_for       : 35
function             : 18
membro               : 15 16
membros              : 2 3 4 16
operator             : 54
operatorbittobit     : 93
params_call          : 61 117 119
primitivetypes       : 107
program              : 0
signature            : 24
sigparams            : 25 26 28
stm                  : 30 31
stms                 : 29 31
type                 : 19 20 25 26 27 28 40 41 42 43 44 45 46 47 48 52 61 62
unaryoperatorprefx   : 91
unaryoperatorsufx    : 92
visibility           : 2 3 4 19 20 25 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class
    (2) class -> . visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> . visibility classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> . visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ABSTRACT        reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    PACKAGE         reduce using rule 8 (visibility -> .)
    STATIC          reduce using rule 8 (visibility -> .)
    VOID            reduce using rule 8 (visibility -> .)
    CLASS           reduce using rule 8 (visibility -> .)

    program                        shift and go to state 1
    class                          shift and go to state 2
    visibility                     shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class .

    $end            reduce using rule 1 (program -> class .)


state 3

    (2) class -> visibility . classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility . classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> visibility . classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (9) classmodifier -> .
    (10) classmodifier -> . ABSTRACT
    (11) classmodifier -> . FINAL
    (12) classmodifier -> . PACKAGE
    (13) classmodifier -> . STATIC
    (14) classmodifier -> . VOID

    CLASS           reduce using rule 9 (classmodifier -> .)
    ABSTRACT        shift and go to state 8
    FINAL           shift and go to state 9
    PACKAGE         shift and go to state 10
    STATIC          shift and go to state 11
    VOID            shift and go to state 12

    classmodifier                  shift and go to state 7

state 4

    (5) visibility -> PUBLIC .

    ABSTRACT        reduce using rule 5 (visibility -> PUBLIC .)
    FINAL           reduce using rule 5 (visibility -> PUBLIC .)
    PACKAGE         reduce using rule 5 (visibility -> PUBLIC .)
    STATIC          reduce using rule 5 (visibility -> PUBLIC .)
    VOID            reduce using rule 5 (visibility -> PUBLIC .)
    CLASS           reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_INT        reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_FLOAT      reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_DOUBLE     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BYTE       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BOOLEAN    reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_CHAR       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_STRING     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_LONG       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_VOID       reduce using rule 5 (visibility -> PUBLIC .)


state 5

    (6) visibility -> PRIVATE .

    ABSTRACT        reduce using rule 6 (visibility -> PRIVATE .)
    FINAL           reduce using rule 6 (visibility -> PRIVATE .)
    PACKAGE         reduce using rule 6 (visibility -> PRIVATE .)
    STATIC          reduce using rule 6 (visibility -> PRIVATE .)
    VOID            reduce using rule 6 (visibility -> PRIVATE .)
    CLASS           reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_INT        reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_FLOAT      reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_DOUBLE     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BYTE       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BOOLEAN    reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_CHAR       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_STRING     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_LONG       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_VOID       reduce using rule 6 (visibility -> PRIVATE .)


state 6

    (7) visibility -> PROTECTED .

    ABSTRACT        reduce using rule 7 (visibility -> PROTECTED .)
    FINAL           reduce using rule 7 (visibility -> PROTECTED .)
    PACKAGE         reduce using rule 7 (visibility -> PROTECTED .)
    STATIC          reduce using rule 7 (visibility -> PROTECTED .)
    VOID            reduce using rule 7 (visibility -> PROTECTED .)
    CLASS           reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_INT        reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_FLOAT      reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_DOUBLE     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BYTE       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BOOLEAN    reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_CHAR       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_STRING     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_LONG       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_VOID       reduce using rule 7 (visibility -> PROTECTED .)


state 7

    (2) class -> visibility classmodifier . CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier . CLASS ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier . CLASS ID IMPLEMENTS LCHAV membros RCHAV

    CLASS           shift and go to state 13


state 8

    (10) classmodifier -> ABSTRACT .

    CLASS           reduce using rule 10 (classmodifier -> ABSTRACT .)


state 9

    (11) classmodifier -> FINAL .

    CLASS           reduce using rule 11 (classmodifier -> FINAL .)


state 10

    (12) classmodifier -> PACKAGE .

    CLASS           reduce using rule 12 (classmodifier -> PACKAGE .)


state 11

    (13) classmodifier -> STATIC .

    CLASS           reduce using rule 13 (classmodifier -> STATIC .)


state 12

    (14) classmodifier -> VOID .

    CLASS           reduce using rule 14 (classmodifier -> VOID .)


state 13

    (2) class -> visibility classmodifier CLASS . ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS . ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS . ID IMPLEMENTS LCHAV membros RCHAV

    ID              shift and go to state 14


state 14

    (2) class -> visibility classmodifier CLASS ID . EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS ID . LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS ID . IMPLEMENTS LCHAV membros RCHAV

    EXTENDS         shift and go to state 15
    LCHAV           shift and go to state 16
    IMPLEMENTS      shift and go to state 17


state 15

    (2) class -> visibility classmodifier CLASS ID EXTENDS . ID LCHAV membros RCHAV

    ID              shift and go to state 18


state 16

    (3) class -> visibility classmodifier CLASS ID LCHAV . membros RCHAV
    (15) membros -> . membro
    (16) membros -> . membro membros
    (17) membro -> . atribute
    (18) membro -> . function
    (19) atribute -> . visibility atributemodifier type ID SEMICOLON
    (20) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (24) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (25) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (26) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 19
    membros                        shift and go to state 20
    membro                         shift and go to state 21
    atribute                       shift and go to state 22
    function                       shift and go to state 23
    signature                      shift and go to state 24

state 17

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS . LCHAV membros RCHAV

    LCHAV           shift and go to state 25


state 18

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID . LCHAV membros RCHAV

    LCHAV           shift and go to state 26


state 19

    (19) atribute -> visibility . atributemodifier type ID SEMICOLON
    (20) atribute -> visibility . atributemodifier type ID EQUAL expression SEMICOLON
    (25) signature -> visibility . atributemodifier type ID LPAREN sigparams RPAREN
    (26) signature -> visibility . atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
    (21) atributemodifier -> .
    (22) atributemodifier -> . STATIC
    (23) atributemodifier -> . FINAL

    TYPE_INT        reduce using rule 21 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> .)
    STATIC          shift and go to state 28
    FINAL           shift and go to state 29

    atributemodifier               shift and go to state 27

state 20

    (3) class -> visibility classmodifier CLASS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 30


state 21

    (15) membros -> membro .
    (16) membros -> membro . membros
    (15) membros -> . membro
    (16) membros -> . membro membros
    (17) membro -> . atribute
    (18) membro -> . function
    (19) atribute -> . visibility atributemodifier type ID SEMICOLON
    (20) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (24) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (25) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (26) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    RCHAV           reduce using rule 15 (membros -> membro .)
    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    membro                         shift and go to state 21
    membros                        shift and go to state 31
    atribute                       shift and go to state 22
    function                       shift and go to state 23
    visibility                     shift and go to state 19
    signature                      shift and go to state 24

state 22

    (17) membro -> atribute .

    PUBLIC          reduce using rule 17 (membro -> atribute .)
    PRIVATE         reduce using rule 17 (membro -> atribute .)
    PROTECTED       reduce using rule 17 (membro -> atribute .)
    STATIC          reduce using rule 17 (membro -> atribute .)
    FINAL           reduce using rule 17 (membro -> atribute .)
    TYPE_INT        reduce using rule 17 (membro -> atribute .)
    TYPE_FLOAT      reduce using rule 17 (membro -> atribute .)
    TYPE_DOUBLE     reduce using rule 17 (membro -> atribute .)
    TYPE_BYTE       reduce using rule 17 (membro -> atribute .)
    TYPE_BOOLEAN    reduce using rule 17 (membro -> atribute .)
    TYPE_CHAR       reduce using rule 17 (membro -> atribute .)
    TYPE_STRING     reduce using rule 17 (membro -> atribute .)
    TYPE_LONG       reduce using rule 17 (membro -> atribute .)
    TYPE_VOID       reduce using rule 17 (membro -> atribute .)
    RCHAV           reduce using rule 17 (membro -> atribute .)


state 23

    (18) membro -> function .

    PUBLIC          reduce using rule 18 (membro -> function .)
    PRIVATE         reduce using rule 18 (membro -> function .)
    PROTECTED       reduce using rule 18 (membro -> function .)
    STATIC          reduce using rule 18 (membro -> function .)
    FINAL           reduce using rule 18 (membro -> function .)
    TYPE_INT        reduce using rule 18 (membro -> function .)
    TYPE_FLOAT      reduce using rule 18 (membro -> function .)
    TYPE_DOUBLE     reduce using rule 18 (membro -> function .)
    TYPE_BYTE       reduce using rule 18 (membro -> function .)
    TYPE_BOOLEAN    reduce using rule 18 (membro -> function .)
    TYPE_CHAR       reduce using rule 18 (membro -> function .)
    TYPE_STRING     reduce using rule 18 (membro -> function .)
    TYPE_LONG       reduce using rule 18 (membro -> function .)
    TYPE_VOID       reduce using rule 18 (membro -> function .)
    RCHAV           reduce using rule 18 (membro -> function .)


state 24

    (24) function -> signature . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    body                           shift and go to state 32

state 25

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV . membros RCHAV
    (15) membros -> . membro
    (16) membros -> . membro membros
    (17) membro -> . atribute
    (18) membro -> . function
    (19) atribute -> . visibility atributemodifier type ID SEMICOLON
    (20) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (24) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (25) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (26) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 19
    membros                        shift and go to state 34
    membro                         shift and go to state 21
    atribute                       shift and go to state 22
    function                       shift and go to state 23
    signature                      shift and go to state 24

state 26

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV . membros RCHAV
    (15) membros -> . membro
    (16) membros -> . membro membros
    (17) membro -> . atribute
    (18) membro -> . function
    (19) atribute -> . visibility atributemodifier type ID SEMICOLON
    (20) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (24) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (25) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (26) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 19
    membros                        shift and go to state 35
    membro                         shift and go to state 21
    atribute                       shift and go to state 22
    function                       shift and go to state 23
    signature                      shift and go to state 24

state 27

    (19) atribute -> visibility atributemodifier . type ID SEMICOLON
    (20) atribute -> visibility atributemodifier . type ID EQUAL expression SEMICOLON
    (25) signature -> visibility atributemodifier . type ID LPAREN sigparams RPAREN
    (26) signature -> visibility atributemodifier . type brackets_expression ID LPAREN sigparams RPAREN
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 36
    primitivetypes                 shift and go to state 37

state 28

    (22) atributemodifier -> STATIC .

    TYPE_INT        reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_FLOAT      reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_DOUBLE     reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_BYTE       reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_BOOLEAN    reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_CHAR       reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_STRING     reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_LONG       reduce using rule 22 (atributemodifier -> STATIC .)
    TYPE_VOID       reduce using rule 22 (atributemodifier -> STATIC .)


state 29

    (23) atributemodifier -> FINAL .

    TYPE_INT        reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_FLOAT      reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_DOUBLE     reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_BYTE       reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_BOOLEAN    reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_CHAR       reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_STRING     reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_LONG       reduce using rule 23 (atributemodifier -> FINAL .)
    TYPE_VOID       reduce using rule 23 (atributemodifier -> FINAL .)


state 30

    (3) class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .

    $end            reduce using rule 3 (class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .)


state 31

    (16) membros -> membro membros .

    RCHAV           reduce using rule 16 (membros -> membro membros .)


state 32

    (24) function -> signature body .

    PUBLIC          reduce using rule 24 (function -> signature body .)
    PRIVATE         reduce using rule 24 (function -> signature body .)
    PROTECTED       reduce using rule 24 (function -> signature body .)
    STATIC          reduce using rule 24 (function -> signature body .)
    FINAL           reduce using rule 24 (function -> signature body .)
    TYPE_INT        reduce using rule 24 (function -> signature body .)
    TYPE_FLOAT      reduce using rule 24 (function -> signature body .)
    TYPE_DOUBLE     reduce using rule 24 (function -> signature body .)
    TYPE_BYTE       reduce using rule 24 (function -> signature body .)
    TYPE_BOOLEAN    reduce using rule 24 (function -> signature body .)
    TYPE_CHAR       reduce using rule 24 (function -> signature body .)
    TYPE_STRING     reduce using rule 24 (function -> signature body .)
    TYPE_LONG       reduce using rule 24 (function -> signature body .)
    TYPE_VOID       reduce using rule 24 (function -> signature body .)
    RCHAV           reduce using rule 24 (function -> signature body .)


state 33

    (29) body -> LCHAV . stms RCHAV
    (30) stms -> . stm
    (31) stms -> . stm stms
    (32) stm -> . expression SEMICOLON
    (33) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (34) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (35) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm
    (37) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (38) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (39) stm -> . SEMICOLON
    (40) stm -> . atributemodifier type ID SEMICOLON
    (41) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (42) stm -> . atributemodifier type ID LBRACKET RBRACKET SEMICOLON
    (43) stm -> . atributemodifier type LBRACKET RBRACKET ID SEMICOLON
    (44) stm -> . atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (45) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (46) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (49) stm -> . RETURN expression SEMICOLON
    (50) stm -> . RETURN SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (21) atributemodifier -> .
    (22) atributemodifier -> . STATIC
    (23) atributemodifier -> . FINAL
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    WHILE           shift and go to state 51
    DO              shift and go to state 52
    FOR             shift and go to state 53
    IF              shift and go to state 54
    SEMICOLON       shift and go to state 50
    RETURN          shift and go to state 57
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    TYPE_INT        reduce using rule 21 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> .)
    STATIC          shift and go to state 28
    FINAL           shift and go to state 29
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    stms                           shift and go to state 47
    stm                            shift and go to state 48
    expression                     shift and go to state 49
    atributemodifier               shift and go to state 55
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 34

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros . RCHAV

    RCHAV           shift and go to state 71


state 35

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 72


state 36

    (19) atribute -> visibility atributemodifier type . ID SEMICOLON
    (20) atribute -> visibility atributemodifier type . ID EQUAL expression SEMICOLON
    (25) signature -> visibility atributemodifier type . ID LPAREN sigparams RPAREN
    (26) signature -> visibility atributemodifier type . brackets_expression ID LPAREN sigparams RPAREN
    (104) brackets_expression -> . LBRACKET RBRACKET
    (105) brackets_expression -> . LBRACKET INT_NUMBER RBRACKET
    (106) brackets_expression -> . LBRACKET ID RBRACKET

    ID              shift and go to state 73
    LBRACKET        shift and go to state 75

    brackets_expression            shift and go to state 74

state 37

    (107) type -> primitivetypes .

    ID              reduce using rule 107 (type -> primitivetypes .)
    LBRACKET        reduce using rule 107 (type -> primitivetypes .)
    LPAREN          reduce using rule 107 (type -> primitivetypes .)


state 38

    (108) primitivetypes -> TYPE_INT .

    ID              reduce using rule 108 (primitivetypes -> TYPE_INT .)
    LBRACKET        reduce using rule 108 (primitivetypes -> TYPE_INT .)
    LPAREN          reduce using rule 108 (primitivetypes -> TYPE_INT .)


state 39

    (109) primitivetypes -> TYPE_FLOAT .

    ID              reduce using rule 109 (primitivetypes -> TYPE_FLOAT .)
    LBRACKET        reduce using rule 109 (primitivetypes -> TYPE_FLOAT .)
    LPAREN          reduce using rule 109 (primitivetypes -> TYPE_FLOAT .)


state 40

    (110) primitivetypes -> TYPE_DOUBLE .

    ID              reduce using rule 110 (primitivetypes -> TYPE_DOUBLE .)
    LBRACKET        reduce using rule 110 (primitivetypes -> TYPE_DOUBLE .)
    LPAREN          reduce using rule 110 (primitivetypes -> TYPE_DOUBLE .)


state 41

    (111) primitivetypes -> TYPE_BYTE .

    ID              reduce using rule 111 (primitivetypes -> TYPE_BYTE .)
    LBRACKET        reduce using rule 111 (primitivetypes -> TYPE_BYTE .)
    LPAREN          reduce using rule 111 (primitivetypes -> TYPE_BYTE .)


state 42

    (112) primitivetypes -> TYPE_BOOLEAN .

    ID              reduce using rule 112 (primitivetypes -> TYPE_BOOLEAN .)
    LBRACKET        reduce using rule 112 (primitivetypes -> TYPE_BOOLEAN .)
    LPAREN          reduce using rule 112 (primitivetypes -> TYPE_BOOLEAN .)


state 43

    (113) primitivetypes -> TYPE_CHAR .

    ID              reduce using rule 113 (primitivetypes -> TYPE_CHAR .)
    LBRACKET        reduce using rule 113 (primitivetypes -> TYPE_CHAR .)
    LPAREN          reduce using rule 113 (primitivetypes -> TYPE_CHAR .)


state 44

    (114) primitivetypes -> TYPE_STRING .

    ID              reduce using rule 114 (primitivetypes -> TYPE_STRING .)
    LBRACKET        reduce using rule 114 (primitivetypes -> TYPE_STRING .)
    LPAREN          reduce using rule 114 (primitivetypes -> TYPE_STRING .)


state 45

    (115) primitivetypes -> TYPE_LONG .

    ID              reduce using rule 115 (primitivetypes -> TYPE_LONG .)
    LBRACKET        reduce using rule 115 (primitivetypes -> TYPE_LONG .)
    LPAREN          reduce using rule 115 (primitivetypes -> TYPE_LONG .)


state 46

    (116) primitivetypes -> TYPE_VOID .

    ID              reduce using rule 116 (primitivetypes -> TYPE_VOID .)
    LBRACKET        reduce using rule 116 (primitivetypes -> TYPE_VOID .)
    LPAREN          reduce using rule 116 (primitivetypes -> TYPE_VOID .)


state 47

    (29) body -> LCHAV stms . RCHAV

    RCHAV           shift and go to state 76


state 48

    (30) stms -> stm .
    (31) stms -> stm . stms
    (30) stms -> . stm
    (31) stms -> . stm stms
    (32) stm -> . expression SEMICOLON
    (33) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (34) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (35) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm
    (37) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (38) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (39) stm -> . SEMICOLON
    (40) stm -> . atributemodifier type ID SEMICOLON
    (41) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (42) stm -> . atributemodifier type ID LBRACKET RBRACKET SEMICOLON
    (43) stm -> . atributemodifier type LBRACKET RBRACKET ID SEMICOLON
    (44) stm -> . atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (45) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (46) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (49) stm -> . RETURN expression SEMICOLON
    (50) stm -> . RETURN SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (21) atributemodifier -> .
    (22) atributemodifier -> . STATIC
    (23) atributemodifier -> . FINAL
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    RCHAV           reduce using rule 30 (stms -> stm .)
    WHILE           shift and go to state 51
    DO              shift and go to state 52
    FOR             shift and go to state 53
    IF              shift and go to state 54
    SEMICOLON       shift and go to state 50
    RETURN          shift and go to state 57
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    TYPE_INT        reduce using rule 21 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> .)
    STATIC          shift and go to state 28
    FINAL           shift and go to state 29
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    stm                            shift and go to state 48
    stms                           shift and go to state 77
    expression                     shift and go to state 49
    atributemodifier               shift and go to state 55
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 49

    (32) stm -> expression . SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 78
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 50

    (39) stm -> SEMICOLON .

    WHILE           reduce using rule 39 (stm -> SEMICOLON .)
    DO              reduce using rule 39 (stm -> SEMICOLON .)
    FOR             reduce using rule 39 (stm -> SEMICOLON .)
    IF              reduce using rule 39 (stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 39 (stm -> SEMICOLON .)
    RETURN          reduce using rule 39 (stm -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 39 (stm -> SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 39 (stm -> SEMICOLON .)
    INT_NUMBER      reduce using rule 39 (stm -> SEMICOLON .)
    STRING          reduce using rule 39 (stm -> SEMICOLON .)
    ID              reduce using rule 39 (stm -> SEMICOLON .)
    NEW             reduce using rule 39 (stm -> SEMICOLON .)
    STATIC          reduce using rule 39 (stm -> SEMICOLON .)
    FINAL           reduce using rule 39 (stm -> SEMICOLON .)
    INCREMENT       reduce using rule 39 (stm -> SEMICOLON .)
    DECREMENT       reduce using rule 39 (stm -> SEMICOLON .)
    MINUS           reduce using rule 39 (stm -> SEMICOLON .)
    PLUS            reduce using rule 39 (stm -> SEMICOLON .)
    NOT             reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_INT        reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_FLOAT      reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_BYTE       reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_STRING     reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_LONG       reduce using rule 39 (stm -> SEMICOLON .)
    TYPE_VOID       reduce using rule 39 (stm -> SEMICOLON .)
    RCHAV           reduce using rule 39 (stm -> SEMICOLON .)


state 51

    (33) stm -> WHILE . LPAREN expression RPAREN bodyorstm

    LPAREN          shift and go to state 99


state 52

    (34) stm -> DO . bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 100
    body                           shift and go to state 101

state 53

    (35) stm -> FOR . LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    LPAREN          shift and go to state 102


state 54

    (36) stm -> IF . LPAREN expression RPAREN bodyorstm
    (37) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (38) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm

    LPAREN          shift and go to state 103


state 55

    (40) stm -> atributemodifier . type ID SEMICOLON
    (41) stm -> atributemodifier . type ID EQUAL expression SEMICOLON
    (42) stm -> atributemodifier . type ID LBRACKET RBRACKET SEMICOLON
    (43) stm -> atributemodifier . type LBRACKET RBRACKET ID SEMICOLON
    (44) stm -> atributemodifier . type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier . type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (46) stm -> atributemodifier . type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> atributemodifier . type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> atributemodifier . type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 104
    primitivetypes                 shift and go to state 37

state 56

    (60) expression -> ID .
    (68) operator -> ID . EQUAL expression
    (69) operator -> ID . MINUS_EQ expression
    (70) operator -> ID . TIMES_EQ expression
    (71) operator -> ID . PLUS_EQ expression
    (72) operator -> ID . DIVIDE_EQ expression
    (73) operator -> ID . MOD_EQ expression
    (74) operator -> ID . BITWISE_AND_EQ expression
    (75) operator -> ID . BITWISE_OR_EQ expression
    (76) operator -> ID . BITWISE_XOR_EQ expression
    (77) operator -> ID . URSHIFT_EQ expression
    (78) operator -> ID . LSHIFT_EQ expression
    (79) operator -> ID . RSHIFT_EQ expression
    (92) operator -> ID . unaryoperatorsufx
    (117) call -> ID . LPAREN params_call RPAREN
    (118) call -> ID . LPAREN RPAREN
    (99) unaryoperatorsufx -> . INCREMENT
    (100) unaryoperatorsufx -> . DECREMENT

    SEMICOLON       reduce using rule 60 (expression -> ID .)
    TIMES           reduce using rule 60 (expression -> ID .)
    DIVIDE          reduce using rule 60 (expression -> ID .)
    MODULE          reduce using rule 60 (expression -> ID .)
    PLUS            reduce using rule 60 (expression -> ID .)
    MINUS           reduce using rule 60 (expression -> ID .)
    LEQ             reduce using rule 60 (expression -> ID .)
    GEQ             reduce using rule 60 (expression -> ID .)
    LT              reduce using rule 60 (expression -> ID .)
    GT              reduce using rule 60 (expression -> ID .)
    NEQ             reduce using rule 60 (expression -> ID .)
    EQ              reduce using rule 60 (expression -> ID .)
    AND             reduce using rule 60 (expression -> ID .)
    OR              reduce using rule 60 (expression -> ID .)
    BITWISE_AND     reduce using rule 60 (expression -> ID .)
    BITWISE_OR      reduce using rule 60 (expression -> ID .)
    BITWISE_XOR     reduce using rule 60 (expression -> ID .)
    URSHIFT         reduce using rule 60 (expression -> ID .)
    LSHIFT          reduce using rule 60 (expression -> ID .)
    RSHIFT          reduce using rule 60 (expression -> ID .)
    RPAREN          reduce using rule 60 (expression -> ID .)
    COMMA           reduce using rule 60 (expression -> ID .)
    RBRACKET        reduce using rule 60 (expression -> ID .)
    RCHAV           reduce using rule 60 (expression -> ID .)
    EQUAL           shift and go to state 105
    MINUS_EQ        shift and go to state 106
    TIMES_EQ        shift and go to state 107
    PLUS_EQ         shift and go to state 108
    DIVIDE_EQ       shift and go to state 109
    MOD_EQ          shift and go to state 110
    BITWISE_AND_EQ  shift and go to state 111
    BITWISE_OR_EQ   shift and go to state 112
    BITWISE_XOR_EQ  shift and go to state 113
    URSHIFT_EQ      shift and go to state 114
    LSHIFT_EQ       shift and go to state 115
    RSHIFT_EQ       shift and go to state 116
    LPAREN          shift and go to state 118
    INCREMENT       shift and go to state 119
    DECREMENT       shift and go to state 120

    unaryoperatorsufx              shift and go to state 117

state 57

    (49) stm -> RETURN . expression SEMICOLON
    (50) stm -> RETURN . SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    SEMICOLON       shift and go to state 122
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 121
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 58

    (54) expression -> operator .

    SEMICOLON       reduce using rule 54 (expression -> operator .)
    TIMES           reduce using rule 54 (expression -> operator .)
    DIVIDE          reduce using rule 54 (expression -> operator .)
    MODULE          reduce using rule 54 (expression -> operator .)
    PLUS            reduce using rule 54 (expression -> operator .)
    MINUS           reduce using rule 54 (expression -> operator .)
    LEQ             reduce using rule 54 (expression -> operator .)
    GEQ             reduce using rule 54 (expression -> operator .)
    LT              reduce using rule 54 (expression -> operator .)
    GT              reduce using rule 54 (expression -> operator .)
    NEQ             reduce using rule 54 (expression -> operator .)
    EQ              reduce using rule 54 (expression -> operator .)
    AND             reduce using rule 54 (expression -> operator .)
    OR              reduce using rule 54 (expression -> operator .)
    BITWISE_AND     reduce using rule 54 (expression -> operator .)
    BITWISE_OR      reduce using rule 54 (expression -> operator .)
    BITWISE_XOR     reduce using rule 54 (expression -> operator .)
    URSHIFT         reduce using rule 54 (expression -> operator .)
    LSHIFT          reduce using rule 54 (expression -> operator .)
    RSHIFT          reduce using rule 54 (expression -> operator .)
    RPAREN          reduce using rule 54 (expression -> operator .)
    COMMA           reduce using rule 54 (expression -> operator .)
    RBRACKET        reduce using rule 54 (expression -> operator .)
    RCHAV           reduce using rule 54 (expression -> operator .)


state 59

    (55) expression -> call .

    SEMICOLON       reduce using rule 55 (expression -> call .)
    TIMES           reduce using rule 55 (expression -> call .)
    DIVIDE          reduce using rule 55 (expression -> call .)
    MODULE          reduce using rule 55 (expression -> call .)
    PLUS            reduce using rule 55 (expression -> call .)
    MINUS           reduce using rule 55 (expression -> call .)
    LEQ             reduce using rule 55 (expression -> call .)
    GEQ             reduce using rule 55 (expression -> call .)
    LT              reduce using rule 55 (expression -> call .)
    GT              reduce using rule 55 (expression -> call .)
    NEQ             reduce using rule 55 (expression -> call .)
    EQ              reduce using rule 55 (expression -> call .)
    AND             reduce using rule 55 (expression -> call .)
    OR              reduce using rule 55 (expression -> call .)
    BITWISE_AND     reduce using rule 55 (expression -> call .)
    BITWISE_OR      reduce using rule 55 (expression -> call .)
    BITWISE_XOR     reduce using rule 55 (expression -> call .)
    URSHIFT         reduce using rule 55 (expression -> call .)
    LSHIFT          reduce using rule 55 (expression -> call .)
    RSHIFT          reduce using rule 55 (expression -> call .)
    RPAREN          reduce using rule 55 (expression -> call .)
    COMMA           reduce using rule 55 (expression -> call .)
    RBRACKET        reduce using rule 55 (expression -> call .)
    RCHAV           reduce using rule 55 (expression -> call .)


state 60

    (56) expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 56 (expression -> FLOAT_NUMBER .)
    TIMES           reduce using rule 56 (expression -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 56 (expression -> FLOAT_NUMBER .)
    MODULE          reduce using rule 56 (expression -> FLOAT_NUMBER .)
    PLUS            reduce using rule 56 (expression -> FLOAT_NUMBER .)
    MINUS           reduce using rule 56 (expression -> FLOAT_NUMBER .)
    LEQ             reduce using rule 56 (expression -> FLOAT_NUMBER .)
    GEQ             reduce using rule 56 (expression -> FLOAT_NUMBER .)
    LT              reduce using rule 56 (expression -> FLOAT_NUMBER .)
    GT              reduce using rule 56 (expression -> FLOAT_NUMBER .)
    NEQ             reduce using rule 56 (expression -> FLOAT_NUMBER .)
    EQ              reduce using rule 56 (expression -> FLOAT_NUMBER .)
    AND             reduce using rule 56 (expression -> FLOAT_NUMBER .)
    OR              reduce using rule 56 (expression -> FLOAT_NUMBER .)
    BITWISE_AND     reduce using rule 56 (expression -> FLOAT_NUMBER .)
    BITWISE_OR      reduce using rule 56 (expression -> FLOAT_NUMBER .)
    BITWISE_XOR     reduce using rule 56 (expression -> FLOAT_NUMBER .)
    URSHIFT         reduce using rule 56 (expression -> FLOAT_NUMBER .)
    LSHIFT          reduce using rule 56 (expression -> FLOAT_NUMBER .)
    RSHIFT          reduce using rule 56 (expression -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 56 (expression -> FLOAT_NUMBER .)
    COMMA           reduce using rule 56 (expression -> FLOAT_NUMBER .)
    RBRACKET        reduce using rule 56 (expression -> FLOAT_NUMBER .)
    RCHAV           reduce using rule 56 (expression -> FLOAT_NUMBER .)


state 61

    (57) expression -> DOUBLE_NUMBER .

    SEMICOLON       reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    TIMES           reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    MODULE          reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    LEQ             reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    GEQ             reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    LT              reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    GT              reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    NEQ             reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    EQ              reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    AND             reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    OR              reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    BITWISE_AND     reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    BITWISE_OR      reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    BITWISE_XOR     reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    URSHIFT         reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    LSHIFT          reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    RSHIFT          reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    RPAREN          reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    COMMA           reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    RBRACKET        reduce using rule 57 (expression -> DOUBLE_NUMBER .)
    RCHAV           reduce using rule 57 (expression -> DOUBLE_NUMBER .)


state 62

    (58) expression -> INT_NUMBER .

    SEMICOLON       reduce using rule 58 (expression -> INT_NUMBER .)
    TIMES           reduce using rule 58 (expression -> INT_NUMBER .)
    DIVIDE          reduce using rule 58 (expression -> INT_NUMBER .)
    MODULE          reduce using rule 58 (expression -> INT_NUMBER .)
    PLUS            reduce using rule 58 (expression -> INT_NUMBER .)
    MINUS           reduce using rule 58 (expression -> INT_NUMBER .)
    LEQ             reduce using rule 58 (expression -> INT_NUMBER .)
    GEQ             reduce using rule 58 (expression -> INT_NUMBER .)
    LT              reduce using rule 58 (expression -> INT_NUMBER .)
    GT              reduce using rule 58 (expression -> INT_NUMBER .)
    NEQ             reduce using rule 58 (expression -> INT_NUMBER .)
    EQ              reduce using rule 58 (expression -> INT_NUMBER .)
    AND             reduce using rule 58 (expression -> INT_NUMBER .)
    OR              reduce using rule 58 (expression -> INT_NUMBER .)
    BITWISE_AND     reduce using rule 58 (expression -> INT_NUMBER .)
    BITWISE_OR      reduce using rule 58 (expression -> INT_NUMBER .)
    BITWISE_XOR     reduce using rule 58 (expression -> INT_NUMBER .)
    URSHIFT         reduce using rule 58 (expression -> INT_NUMBER .)
    LSHIFT          reduce using rule 58 (expression -> INT_NUMBER .)
    RSHIFT          reduce using rule 58 (expression -> INT_NUMBER .)
    RPAREN          reduce using rule 58 (expression -> INT_NUMBER .)
    COMMA           reduce using rule 58 (expression -> INT_NUMBER .)
    RBRACKET        reduce using rule 58 (expression -> INT_NUMBER .)
    RCHAV           reduce using rule 58 (expression -> INT_NUMBER .)


state 63

    (59) expression -> STRING .

    SEMICOLON       reduce using rule 59 (expression -> STRING .)
    TIMES           reduce using rule 59 (expression -> STRING .)
    DIVIDE          reduce using rule 59 (expression -> STRING .)
    MODULE          reduce using rule 59 (expression -> STRING .)
    PLUS            reduce using rule 59 (expression -> STRING .)
    MINUS           reduce using rule 59 (expression -> STRING .)
    LEQ             reduce using rule 59 (expression -> STRING .)
    GEQ             reduce using rule 59 (expression -> STRING .)
    LT              reduce using rule 59 (expression -> STRING .)
    GT              reduce using rule 59 (expression -> STRING .)
    NEQ             reduce using rule 59 (expression -> STRING .)
    EQ              reduce using rule 59 (expression -> STRING .)
    AND             reduce using rule 59 (expression -> STRING .)
    OR              reduce using rule 59 (expression -> STRING .)
    BITWISE_AND     reduce using rule 59 (expression -> STRING .)
    BITWISE_OR      reduce using rule 59 (expression -> STRING .)
    BITWISE_XOR     reduce using rule 59 (expression -> STRING .)
    URSHIFT         reduce using rule 59 (expression -> STRING .)
    LSHIFT          reduce using rule 59 (expression -> STRING .)
    RSHIFT          reduce using rule 59 (expression -> STRING .)
    RPAREN          reduce using rule 59 (expression -> STRING .)
    COMMA           reduce using rule 59 (expression -> STRING .)
    RBRACKET        reduce using rule 59 (expression -> STRING .)
    RCHAV           reduce using rule 59 (expression -> STRING .)


state 64

    (61) expression -> NEW . type LPAREN params_call RPAREN
    (62) expression -> NEW . type LBRACKET expression RBRACKET
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 123
    primitivetypes                 shift and go to state 37

state 65

    (97) unaryoperatorprefx -> PLUS .

    ID              reduce using rule 97 (unaryoperatorprefx -> PLUS .)


state 66

    (96) unaryoperatorprefx -> MINUS .

    ID              reduce using rule 96 (unaryoperatorprefx -> MINUS .)


state 67

    (91) operator -> unaryoperatorprefx . ID

    ID              shift and go to state 124


state 68

    (94) unaryoperatorprefx -> INCREMENT .

    ID              reduce using rule 94 (unaryoperatorprefx -> INCREMENT .)


state 69

    (95) unaryoperatorprefx -> DECREMENT .

    ID              reduce using rule 95 (unaryoperatorprefx -> DECREMENT .)


state 70

    (98) unaryoperatorprefx -> NOT .

    ID              reduce using rule 98 (unaryoperatorprefx -> NOT .)


state 71

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .

    $end            reduce using rule 4 (class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .)


state 72

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .

    $end            reduce using rule 2 (class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .)


state 73

    (19) atribute -> visibility atributemodifier type ID . SEMICOLON
    (20) atribute -> visibility atributemodifier type ID . EQUAL expression SEMICOLON
    (25) signature -> visibility atributemodifier type ID . LPAREN sigparams RPAREN

    SEMICOLON       shift and go to state 125
    EQUAL           shift and go to state 126
    LPAREN          shift and go to state 127


state 74

    (26) signature -> visibility atributemodifier type brackets_expression . ID LPAREN sigparams RPAREN

    ID              shift and go to state 128


state 75

    (104) brackets_expression -> LBRACKET . RBRACKET
    (105) brackets_expression -> LBRACKET . INT_NUMBER RBRACKET
    (106) brackets_expression -> LBRACKET . ID RBRACKET

    RBRACKET        shift and go to state 129
    INT_NUMBER      shift and go to state 130
    ID              shift and go to state 131


state 76

    (29) body -> LCHAV stms RCHAV .

    PUBLIC          reduce using rule 29 (body -> LCHAV stms RCHAV .)
    PRIVATE         reduce using rule 29 (body -> LCHAV stms RCHAV .)
    PROTECTED       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    STATIC          reduce using rule 29 (body -> LCHAV stms RCHAV .)
    FINAL           reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_INT        reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_FLOAT      reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_DOUBLE     reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_BYTE       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_BOOLEAN    reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_CHAR       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_STRING     reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_LONG       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    TYPE_VOID       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    RCHAV           reduce using rule 29 (body -> LCHAV stms RCHAV .)
    WHILE           reduce using rule 29 (body -> LCHAV stms RCHAV .)
    DO              reduce using rule 29 (body -> LCHAV stms RCHAV .)
    FOR             reduce using rule 29 (body -> LCHAV stms RCHAV .)
    IF              reduce using rule 29 (body -> LCHAV stms RCHAV .)
    SEMICOLON       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    RETURN          reduce using rule 29 (body -> LCHAV stms RCHAV .)
    FLOAT_NUMBER    reduce using rule 29 (body -> LCHAV stms RCHAV .)
    DOUBLE_NUMBER   reduce using rule 29 (body -> LCHAV stms RCHAV .)
    INT_NUMBER      reduce using rule 29 (body -> LCHAV stms RCHAV .)
    STRING          reduce using rule 29 (body -> LCHAV stms RCHAV .)
    ID              reduce using rule 29 (body -> LCHAV stms RCHAV .)
    NEW             reduce using rule 29 (body -> LCHAV stms RCHAV .)
    INCREMENT       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    DECREMENT       reduce using rule 29 (body -> LCHAV stms RCHAV .)
    MINUS           reduce using rule 29 (body -> LCHAV stms RCHAV .)
    PLUS            reduce using rule 29 (body -> LCHAV stms RCHAV .)
    NOT             reduce using rule 29 (body -> LCHAV stms RCHAV .)
    ELSE            reduce using rule 29 (body -> LCHAV stms RCHAV .)


state 77

    (31) stms -> stm stms .

    RCHAV           reduce using rule 31 (stms -> stm stms .)


state 78

    (32) stm -> expression SEMICOLON .

    WHILE           reduce using rule 32 (stm -> expression SEMICOLON .)
    DO              reduce using rule 32 (stm -> expression SEMICOLON .)
    FOR             reduce using rule 32 (stm -> expression SEMICOLON .)
    IF              reduce using rule 32 (stm -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 32 (stm -> expression SEMICOLON .)
    RETURN          reduce using rule 32 (stm -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 32 (stm -> expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 32 (stm -> expression SEMICOLON .)
    INT_NUMBER      reduce using rule 32 (stm -> expression SEMICOLON .)
    STRING          reduce using rule 32 (stm -> expression SEMICOLON .)
    ID              reduce using rule 32 (stm -> expression SEMICOLON .)
    NEW             reduce using rule 32 (stm -> expression SEMICOLON .)
    STATIC          reduce using rule 32 (stm -> expression SEMICOLON .)
    FINAL           reduce using rule 32 (stm -> expression SEMICOLON .)
    INCREMENT       reduce using rule 32 (stm -> expression SEMICOLON .)
    DECREMENT       reduce using rule 32 (stm -> expression SEMICOLON .)
    MINUS           reduce using rule 32 (stm -> expression SEMICOLON .)
    PLUS            reduce using rule 32 (stm -> expression SEMICOLON .)
    NOT             reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_LONG       reduce using rule 32 (stm -> expression SEMICOLON .)
    TYPE_VOID       reduce using rule 32 (stm -> expression SEMICOLON .)
    RCHAV           reduce using rule 32 (stm -> expression SEMICOLON .)


state 79

    (63) operator -> expression TIMES . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 132
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 80

    (64) operator -> expression DIVIDE . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 133
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 81

    (65) operator -> expression MODULE . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 134
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 82

    (66) operator -> expression PLUS . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 135
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 83

    (67) operator -> expression MINUS . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 136
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 84

    (80) operator -> expression LEQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 137
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 85

    (81) operator -> expression GEQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 138
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 86

    (82) operator -> expression LT . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 139
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 87

    (83) operator -> expression GT . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 140
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 88

    (84) operator -> expression NEQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 141
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 89

    (85) operator -> expression EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 142
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 90

    (86) operator -> expression AND . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 143
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 91

    (87) operator -> expression OR . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 144
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 92

    (88) operator -> expression BITWISE_AND . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 145
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 93

    (89) operator -> expression BITWISE_OR . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 146
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 94

    (90) operator -> expression BITWISE_XOR . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 147
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 95

    (93) operator -> expression operatorbittobit .

    SEMICOLON       reduce using rule 93 (operator -> expression operatorbittobit .)
    TIMES           reduce using rule 93 (operator -> expression operatorbittobit .)
    DIVIDE          reduce using rule 93 (operator -> expression operatorbittobit .)
    MODULE          reduce using rule 93 (operator -> expression operatorbittobit .)
    PLUS            reduce using rule 93 (operator -> expression operatorbittobit .)
    MINUS           reduce using rule 93 (operator -> expression operatorbittobit .)
    LEQ             reduce using rule 93 (operator -> expression operatorbittobit .)
    GEQ             reduce using rule 93 (operator -> expression operatorbittobit .)
    LT              reduce using rule 93 (operator -> expression operatorbittobit .)
    GT              reduce using rule 93 (operator -> expression operatorbittobit .)
    NEQ             reduce using rule 93 (operator -> expression operatorbittobit .)
    EQ              reduce using rule 93 (operator -> expression operatorbittobit .)
    AND             reduce using rule 93 (operator -> expression operatorbittobit .)
    OR              reduce using rule 93 (operator -> expression operatorbittobit .)
    BITWISE_AND     reduce using rule 93 (operator -> expression operatorbittobit .)
    BITWISE_OR      reduce using rule 93 (operator -> expression operatorbittobit .)
    BITWISE_XOR     reduce using rule 93 (operator -> expression operatorbittobit .)
    URSHIFT         reduce using rule 93 (operator -> expression operatorbittobit .)
    LSHIFT          reduce using rule 93 (operator -> expression operatorbittobit .)
    RSHIFT          reduce using rule 93 (operator -> expression operatorbittobit .)
    RPAREN          reduce using rule 93 (operator -> expression operatorbittobit .)
    COMMA           reduce using rule 93 (operator -> expression operatorbittobit .)
    RBRACKET        reduce using rule 93 (operator -> expression operatorbittobit .)
    RCHAV           reduce using rule 93 (operator -> expression operatorbittobit .)


state 96

    (101) operatorbittobit -> URSHIFT .

    SEMICOLON       reduce using rule 101 (operatorbittobit -> URSHIFT .)
    TIMES           reduce using rule 101 (operatorbittobit -> URSHIFT .)
    DIVIDE          reduce using rule 101 (operatorbittobit -> URSHIFT .)
    MODULE          reduce using rule 101 (operatorbittobit -> URSHIFT .)
    PLUS            reduce using rule 101 (operatorbittobit -> URSHIFT .)
    MINUS           reduce using rule 101 (operatorbittobit -> URSHIFT .)
    LEQ             reduce using rule 101 (operatorbittobit -> URSHIFT .)
    GEQ             reduce using rule 101 (operatorbittobit -> URSHIFT .)
    LT              reduce using rule 101 (operatorbittobit -> URSHIFT .)
    GT              reduce using rule 101 (operatorbittobit -> URSHIFT .)
    NEQ             reduce using rule 101 (operatorbittobit -> URSHIFT .)
    EQ              reduce using rule 101 (operatorbittobit -> URSHIFT .)
    AND             reduce using rule 101 (operatorbittobit -> URSHIFT .)
    OR              reduce using rule 101 (operatorbittobit -> URSHIFT .)
    BITWISE_AND     reduce using rule 101 (operatorbittobit -> URSHIFT .)
    BITWISE_OR      reduce using rule 101 (operatorbittobit -> URSHIFT .)
    BITWISE_XOR     reduce using rule 101 (operatorbittobit -> URSHIFT .)
    URSHIFT         reduce using rule 101 (operatorbittobit -> URSHIFT .)
    LSHIFT          reduce using rule 101 (operatorbittobit -> URSHIFT .)
    RSHIFT          reduce using rule 101 (operatorbittobit -> URSHIFT .)
    RPAREN          reduce using rule 101 (operatorbittobit -> URSHIFT .)
    COMMA           reduce using rule 101 (operatorbittobit -> URSHIFT .)
    RBRACKET        reduce using rule 101 (operatorbittobit -> URSHIFT .)
    RCHAV           reduce using rule 101 (operatorbittobit -> URSHIFT .)


state 97

    (102) operatorbittobit -> LSHIFT .

    SEMICOLON       reduce using rule 102 (operatorbittobit -> LSHIFT .)
    TIMES           reduce using rule 102 (operatorbittobit -> LSHIFT .)
    DIVIDE          reduce using rule 102 (operatorbittobit -> LSHIFT .)
    MODULE          reduce using rule 102 (operatorbittobit -> LSHIFT .)
    PLUS            reduce using rule 102 (operatorbittobit -> LSHIFT .)
    MINUS           reduce using rule 102 (operatorbittobit -> LSHIFT .)
    LEQ             reduce using rule 102 (operatorbittobit -> LSHIFT .)
    GEQ             reduce using rule 102 (operatorbittobit -> LSHIFT .)
    LT              reduce using rule 102 (operatorbittobit -> LSHIFT .)
    GT              reduce using rule 102 (operatorbittobit -> LSHIFT .)
    NEQ             reduce using rule 102 (operatorbittobit -> LSHIFT .)
    EQ              reduce using rule 102 (operatorbittobit -> LSHIFT .)
    AND             reduce using rule 102 (operatorbittobit -> LSHIFT .)
    OR              reduce using rule 102 (operatorbittobit -> LSHIFT .)
    BITWISE_AND     reduce using rule 102 (operatorbittobit -> LSHIFT .)
    BITWISE_OR      reduce using rule 102 (operatorbittobit -> LSHIFT .)
    BITWISE_XOR     reduce using rule 102 (operatorbittobit -> LSHIFT .)
    URSHIFT         reduce using rule 102 (operatorbittobit -> LSHIFT .)
    LSHIFT          reduce using rule 102 (operatorbittobit -> LSHIFT .)
    RSHIFT          reduce using rule 102 (operatorbittobit -> LSHIFT .)
    RPAREN          reduce using rule 102 (operatorbittobit -> LSHIFT .)
    COMMA           reduce using rule 102 (operatorbittobit -> LSHIFT .)
    RBRACKET        reduce using rule 102 (operatorbittobit -> LSHIFT .)
    RCHAV           reduce using rule 102 (operatorbittobit -> LSHIFT .)


state 98

    (103) operatorbittobit -> RSHIFT .

    SEMICOLON       reduce using rule 103 (operatorbittobit -> RSHIFT .)
    TIMES           reduce using rule 103 (operatorbittobit -> RSHIFT .)
    DIVIDE          reduce using rule 103 (operatorbittobit -> RSHIFT .)
    MODULE          reduce using rule 103 (operatorbittobit -> RSHIFT .)
    PLUS            reduce using rule 103 (operatorbittobit -> RSHIFT .)
    MINUS           reduce using rule 103 (operatorbittobit -> RSHIFT .)
    LEQ             reduce using rule 103 (operatorbittobit -> RSHIFT .)
    GEQ             reduce using rule 103 (operatorbittobit -> RSHIFT .)
    LT              reduce using rule 103 (operatorbittobit -> RSHIFT .)
    GT              reduce using rule 103 (operatorbittobit -> RSHIFT .)
    NEQ             reduce using rule 103 (operatorbittobit -> RSHIFT .)
    EQ              reduce using rule 103 (operatorbittobit -> RSHIFT .)
    AND             reduce using rule 103 (operatorbittobit -> RSHIFT .)
    OR              reduce using rule 103 (operatorbittobit -> RSHIFT .)
    BITWISE_AND     reduce using rule 103 (operatorbittobit -> RSHIFT .)
    BITWISE_OR      reduce using rule 103 (operatorbittobit -> RSHIFT .)
    BITWISE_XOR     reduce using rule 103 (operatorbittobit -> RSHIFT .)
    URSHIFT         reduce using rule 103 (operatorbittobit -> RSHIFT .)
    LSHIFT          reduce using rule 103 (operatorbittobit -> RSHIFT .)
    RSHIFT          reduce using rule 103 (operatorbittobit -> RSHIFT .)
    RPAREN          reduce using rule 103 (operatorbittobit -> RSHIFT .)
    COMMA           reduce using rule 103 (operatorbittobit -> RSHIFT .)
    RBRACKET        reduce using rule 103 (operatorbittobit -> RSHIFT .)
    RCHAV           reduce using rule 103 (operatorbittobit -> RSHIFT .)


state 99

    (33) stm -> WHILE LPAREN . expression RPAREN bodyorstm
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 148
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 100

    (34) stm -> DO bodyorstm . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 149


state 101

    (51) bodyorstm -> body .

    WHILE           reduce using rule 51 (bodyorstm -> body .)
    DO              reduce using rule 51 (bodyorstm -> body .)
    FOR             reduce using rule 51 (bodyorstm -> body .)
    IF              reduce using rule 51 (bodyorstm -> body .)
    SEMICOLON       reduce using rule 51 (bodyorstm -> body .)
    RETURN          reduce using rule 51 (bodyorstm -> body .)
    FLOAT_NUMBER    reduce using rule 51 (bodyorstm -> body .)
    DOUBLE_NUMBER   reduce using rule 51 (bodyorstm -> body .)
    INT_NUMBER      reduce using rule 51 (bodyorstm -> body .)
    STRING          reduce using rule 51 (bodyorstm -> body .)
    ID              reduce using rule 51 (bodyorstm -> body .)
    NEW             reduce using rule 51 (bodyorstm -> body .)
    STATIC          reduce using rule 51 (bodyorstm -> body .)
    FINAL           reduce using rule 51 (bodyorstm -> body .)
    INCREMENT       reduce using rule 51 (bodyorstm -> body .)
    DECREMENT       reduce using rule 51 (bodyorstm -> body .)
    MINUS           reduce using rule 51 (bodyorstm -> body .)
    PLUS            reduce using rule 51 (bodyorstm -> body .)
    NOT             reduce using rule 51 (bodyorstm -> body .)
    TYPE_INT        reduce using rule 51 (bodyorstm -> body .)
    TYPE_FLOAT      reduce using rule 51 (bodyorstm -> body .)
    TYPE_DOUBLE     reduce using rule 51 (bodyorstm -> body .)
    TYPE_BYTE       reduce using rule 51 (bodyorstm -> body .)
    TYPE_BOOLEAN    reduce using rule 51 (bodyorstm -> body .)
    TYPE_CHAR       reduce using rule 51 (bodyorstm -> body .)
    TYPE_STRING     reduce using rule 51 (bodyorstm -> body .)
    TYPE_LONG       reduce using rule 51 (bodyorstm -> body .)
    TYPE_VOID       reduce using rule 51 (bodyorstm -> body .)
    RCHAV           reduce using rule 51 (bodyorstm -> body .)
    ELSE            reduce using rule 51 (bodyorstm -> body .)


state 102

    (35) stm -> FOR LPAREN . expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (52) expression_for -> . type ID EQUAL expression
    (53) expression_for -> . ID EQUAL expression
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    ID              shift and go to state 152
    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    expression_for                 shift and go to state 150
    type                           shift and go to state 151
    primitivetypes                 shift and go to state 37

state 103

    (36) stm -> IF LPAREN . expression RPAREN bodyorstm
    (37) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE bodyorstm
    (38) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE IF bodyorstm
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 153
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 104

    (40) stm -> atributemodifier type . ID SEMICOLON
    (41) stm -> atributemodifier type . ID EQUAL expression SEMICOLON
    (42) stm -> atributemodifier type . ID LBRACKET RBRACKET SEMICOLON
    (43) stm -> atributemodifier type . LBRACKET RBRACKET ID SEMICOLON
    (44) stm -> atributemodifier type . LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier type . ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (46) stm -> atributemodifier type . ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> atributemodifier type . LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> atributemodifier type . LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    ID              shift and go to state 154
    LBRACKET        shift and go to state 155


state 105

    (68) operator -> ID EQUAL . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 156
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 106

    (69) operator -> ID MINUS_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 157
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 107

    (70) operator -> ID TIMES_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 158
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 108

    (71) operator -> ID PLUS_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 159
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 109

    (72) operator -> ID DIVIDE_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 160
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 110

    (73) operator -> ID MOD_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 161
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 111

    (74) operator -> ID BITWISE_AND_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 162
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 112

    (75) operator -> ID BITWISE_OR_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 163
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 113

    (76) operator -> ID BITWISE_XOR_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 164
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 114

    (77) operator -> ID URSHIFT_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 165
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 115

    (78) operator -> ID LSHIFT_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 166
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 116

    (79) operator -> ID RSHIFT_EQ . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 167
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 117

    (92) operator -> ID unaryoperatorsufx .

    SEMICOLON       reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    TIMES           reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    DIVIDE          reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    MODULE          reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    PLUS            reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    MINUS           reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    LEQ             reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    GEQ             reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    LT              reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    GT              reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    NEQ             reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    EQ              reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    AND             reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    OR              reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    BITWISE_AND     reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    BITWISE_OR      reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    BITWISE_XOR     reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    URSHIFT         reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    LSHIFT          reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    RSHIFT          reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    RPAREN          reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    COMMA           reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    RBRACKET        reduce using rule 92 (operator -> ID unaryoperatorsufx .)
    RCHAV           reduce using rule 92 (operator -> ID unaryoperatorsufx .)


state 118

    (117) call -> ID LPAREN . params_call RPAREN
    (118) call -> ID LPAREN . RPAREN
    (119) params_call -> . expression COMMA params_call
    (120) params_call -> . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    RPAREN          shift and go to state 169
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    params_call                    shift and go to state 168
    expression                     shift and go to state 170
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 119

    (99) unaryoperatorsufx -> INCREMENT .

    SEMICOLON       reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    TIMES           reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    DIVIDE          reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    MODULE          reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    PLUS            reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    MINUS           reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    LEQ             reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    GEQ             reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    LT              reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    GT              reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    NEQ             reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    EQ              reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    AND             reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    OR              reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_AND     reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_OR      reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_XOR     reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    URSHIFT         reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    LSHIFT          reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    RSHIFT          reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    RPAREN          reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    COMMA           reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    RBRACKET        reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)
    RCHAV           reduce using rule 99 (unaryoperatorsufx -> INCREMENT .)


state 120

    (100) unaryoperatorsufx -> DECREMENT .

    SEMICOLON       reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    TIMES           reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    DIVIDE          reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    MODULE          reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    PLUS            reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    MINUS           reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    LEQ             reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    GEQ             reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    LT              reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    GT              reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    NEQ             reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    EQ              reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    AND             reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    OR              reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_AND     reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_OR      reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_XOR     reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    URSHIFT         reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    LSHIFT          reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    RSHIFT          reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    RPAREN          reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    COMMA           reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    RBRACKET        reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)
    RCHAV           reduce using rule 100 (unaryoperatorsufx -> DECREMENT .)


state 121

    (49) stm -> RETURN expression . SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 171
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 122

    (50) stm -> RETURN SEMICOLON .

    WHILE           reduce using rule 50 (stm -> RETURN SEMICOLON .)
    DO              reduce using rule 50 (stm -> RETURN SEMICOLON .)
    FOR             reduce using rule 50 (stm -> RETURN SEMICOLON .)
    IF              reduce using rule 50 (stm -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    RETURN          reduce using rule 50 (stm -> RETURN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 50 (stm -> RETURN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 50 (stm -> RETURN SEMICOLON .)
    INT_NUMBER      reduce using rule 50 (stm -> RETURN SEMICOLON .)
    STRING          reduce using rule 50 (stm -> RETURN SEMICOLON .)
    ID              reduce using rule 50 (stm -> RETURN SEMICOLON .)
    NEW             reduce using rule 50 (stm -> RETURN SEMICOLON .)
    STATIC          reduce using rule 50 (stm -> RETURN SEMICOLON .)
    FINAL           reduce using rule 50 (stm -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    MINUS           reduce using rule 50 (stm -> RETURN SEMICOLON .)
    PLUS            reduce using rule 50 (stm -> RETURN SEMICOLON .)
    NOT             reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_INT        reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_BYTE       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_CHAR       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_STRING     reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_LONG       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    TYPE_VOID       reduce using rule 50 (stm -> RETURN SEMICOLON .)
    RCHAV           reduce using rule 50 (stm -> RETURN SEMICOLON .)


state 123

    (61) expression -> NEW type . LPAREN params_call RPAREN
    (62) expression -> NEW type . LBRACKET expression RBRACKET

    LPAREN          shift and go to state 172
    LBRACKET        shift and go to state 173


state 124

    (91) operator -> unaryoperatorprefx ID .

    SEMICOLON       reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    TIMES           reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    DIVIDE          reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    MODULE          reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    PLUS            reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    MINUS           reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    LEQ             reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    GEQ             reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    LT              reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    GT              reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    NEQ             reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    EQ              reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    AND             reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    OR              reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    BITWISE_AND     reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    BITWISE_OR      reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    BITWISE_XOR     reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    URSHIFT         reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    LSHIFT          reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    RSHIFT          reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    RPAREN          reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    COMMA           reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    RBRACKET        reduce using rule 91 (operator -> unaryoperatorprefx ID .)
    RCHAV           reduce using rule 91 (operator -> unaryoperatorprefx ID .)


state 125

    (19) atribute -> visibility atributemodifier type ID SEMICOLON .

    PUBLIC          reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PRIVATE         reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PROTECTED       reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 19 (atribute -> visibility atributemodifier type ID SEMICOLON .)


state 126

    (20) atribute -> visibility atributemodifier type ID EQUAL . expression SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 174
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 127

    (25) signature -> visibility atributemodifier type ID LPAREN . sigparams RPAREN
    (27) sigparams -> . type ID
    (28) sigparams -> . type ID COMMA sigparams
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 175
    sigparams                      shift and go to state 176
    primitivetypes                 shift and go to state 37

state 128

    (26) signature -> visibility atributemodifier type brackets_expression ID . LPAREN sigparams RPAREN

    LPAREN          shift and go to state 177


state 129

    (104) brackets_expression -> LBRACKET RBRACKET .

    ID              reduce using rule 104 (brackets_expression -> LBRACKET RBRACKET .)


state 130

    (105) brackets_expression -> LBRACKET INT_NUMBER . RBRACKET

    RBRACKET        shift and go to state 178


state 131

    (106) brackets_expression -> LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 179


state 132

    (63) operator -> expression TIMES expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 63 (operator -> expression TIMES expression .)
    TIMES           reduce using rule 63 (operator -> expression TIMES expression .)
    DIVIDE          reduce using rule 63 (operator -> expression TIMES expression .)
    MODULE          reduce using rule 63 (operator -> expression TIMES expression .)
    PLUS            reduce using rule 63 (operator -> expression TIMES expression .)
    MINUS           reduce using rule 63 (operator -> expression TIMES expression .)
    LEQ             reduce using rule 63 (operator -> expression TIMES expression .)
    GEQ             reduce using rule 63 (operator -> expression TIMES expression .)
    LT              reduce using rule 63 (operator -> expression TIMES expression .)
    GT              reduce using rule 63 (operator -> expression TIMES expression .)
    NEQ             reduce using rule 63 (operator -> expression TIMES expression .)
    EQ              reduce using rule 63 (operator -> expression TIMES expression .)
    AND             reduce using rule 63 (operator -> expression TIMES expression .)
    OR              reduce using rule 63 (operator -> expression TIMES expression .)
    BITWISE_AND     reduce using rule 63 (operator -> expression TIMES expression .)
    BITWISE_OR      reduce using rule 63 (operator -> expression TIMES expression .)
    BITWISE_XOR     reduce using rule 63 (operator -> expression TIMES expression .)
    URSHIFT         reduce using rule 63 (operator -> expression TIMES expression .)
    LSHIFT          reduce using rule 63 (operator -> expression TIMES expression .)
    RSHIFT          reduce using rule 63 (operator -> expression TIMES expression .)
    RPAREN          reduce using rule 63 (operator -> expression TIMES expression .)
    COMMA           reduce using rule 63 (operator -> expression TIMES expression .)
    RBRACKET        reduce using rule 63 (operator -> expression TIMES expression .)
    RCHAV           reduce using rule 63 (operator -> expression TIMES expression .)

  ! TIMES           [ shift and go to state 79 ]
  ! DIVIDE          [ shift and go to state 80 ]
  ! MODULE          [ shift and go to state 81 ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]
  ! URSHIFT         [ shift and go to state 96 ]
  ! LSHIFT          [ shift and go to state 97 ]
  ! RSHIFT          [ shift and go to state 98 ]

    operatorbittobit               shift and go to state 95

state 133

    (64) operator -> expression DIVIDE expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 64 (operator -> expression DIVIDE expression .)
    TIMES           reduce using rule 64 (operator -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 64 (operator -> expression DIVIDE expression .)
    MODULE          reduce using rule 64 (operator -> expression DIVIDE expression .)
    PLUS            reduce using rule 64 (operator -> expression DIVIDE expression .)
    MINUS           reduce using rule 64 (operator -> expression DIVIDE expression .)
    LEQ             reduce using rule 64 (operator -> expression DIVIDE expression .)
    GEQ             reduce using rule 64 (operator -> expression DIVIDE expression .)
    LT              reduce using rule 64 (operator -> expression DIVIDE expression .)
    GT              reduce using rule 64 (operator -> expression DIVIDE expression .)
    NEQ             reduce using rule 64 (operator -> expression DIVIDE expression .)
    EQ              reduce using rule 64 (operator -> expression DIVIDE expression .)
    AND             reduce using rule 64 (operator -> expression DIVIDE expression .)
    OR              reduce using rule 64 (operator -> expression DIVIDE expression .)
    BITWISE_AND     reduce using rule 64 (operator -> expression DIVIDE expression .)
    BITWISE_OR      reduce using rule 64 (operator -> expression DIVIDE expression .)
    BITWISE_XOR     reduce using rule 64 (operator -> expression DIVIDE expression .)
    URSHIFT         reduce using rule 64 (operator -> expression DIVIDE expression .)
    LSHIFT          reduce using rule 64 (operator -> expression DIVIDE expression .)
    RSHIFT          reduce using rule 64 (operator -> expression DIVIDE expression .)
    RPAREN          reduce using rule 64 (operator -> expression DIVIDE expression .)
    COMMA           reduce using rule 64 (operator -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 64 (operator -> expression DIVIDE expression .)
    RCHAV           reduce using rule 64 (operator -> expression DIVIDE expression .)

  ! TIMES           [ shift and go to state 79 ]
  ! DIVIDE          [ shift and go to state 80 ]
  ! MODULE          [ shift and go to state 81 ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]
  ! URSHIFT         [ shift and go to state 96 ]
  ! LSHIFT          [ shift and go to state 97 ]
  ! RSHIFT          [ shift and go to state 98 ]

    operatorbittobit               shift and go to state 95

state 134

    (65) operator -> expression MODULE expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 65 (operator -> expression MODULE expression .)
    TIMES           reduce using rule 65 (operator -> expression MODULE expression .)
    DIVIDE          reduce using rule 65 (operator -> expression MODULE expression .)
    MODULE          reduce using rule 65 (operator -> expression MODULE expression .)
    PLUS            reduce using rule 65 (operator -> expression MODULE expression .)
    MINUS           reduce using rule 65 (operator -> expression MODULE expression .)
    LEQ             reduce using rule 65 (operator -> expression MODULE expression .)
    GEQ             reduce using rule 65 (operator -> expression MODULE expression .)
    LT              reduce using rule 65 (operator -> expression MODULE expression .)
    GT              reduce using rule 65 (operator -> expression MODULE expression .)
    NEQ             reduce using rule 65 (operator -> expression MODULE expression .)
    EQ              reduce using rule 65 (operator -> expression MODULE expression .)
    AND             reduce using rule 65 (operator -> expression MODULE expression .)
    OR              reduce using rule 65 (operator -> expression MODULE expression .)
    BITWISE_AND     reduce using rule 65 (operator -> expression MODULE expression .)
    BITWISE_OR      reduce using rule 65 (operator -> expression MODULE expression .)
    BITWISE_XOR     reduce using rule 65 (operator -> expression MODULE expression .)
    URSHIFT         reduce using rule 65 (operator -> expression MODULE expression .)
    LSHIFT          reduce using rule 65 (operator -> expression MODULE expression .)
    RSHIFT          reduce using rule 65 (operator -> expression MODULE expression .)
    RPAREN          reduce using rule 65 (operator -> expression MODULE expression .)
    COMMA           reduce using rule 65 (operator -> expression MODULE expression .)
    RBRACKET        reduce using rule 65 (operator -> expression MODULE expression .)
    RCHAV           reduce using rule 65 (operator -> expression MODULE expression .)

  ! TIMES           [ shift and go to state 79 ]
  ! DIVIDE          [ shift and go to state 80 ]
  ! MODULE          [ shift and go to state 81 ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]
  ! URSHIFT         [ shift and go to state 96 ]
  ! LSHIFT          [ shift and go to state 97 ]
  ! RSHIFT          [ shift and go to state 98 ]

    operatorbittobit               shift and go to state 95

state 135

    (66) operator -> expression PLUS expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 66 (operator -> expression PLUS expression .)
    PLUS            reduce using rule 66 (operator -> expression PLUS expression .)
    MINUS           reduce using rule 66 (operator -> expression PLUS expression .)
    LEQ             reduce using rule 66 (operator -> expression PLUS expression .)
    GEQ             reduce using rule 66 (operator -> expression PLUS expression .)
    LT              reduce using rule 66 (operator -> expression PLUS expression .)
    GT              reduce using rule 66 (operator -> expression PLUS expression .)
    NEQ             reduce using rule 66 (operator -> expression PLUS expression .)
    EQ              reduce using rule 66 (operator -> expression PLUS expression .)
    AND             reduce using rule 66 (operator -> expression PLUS expression .)
    OR              reduce using rule 66 (operator -> expression PLUS expression .)
    BITWISE_AND     reduce using rule 66 (operator -> expression PLUS expression .)
    BITWISE_OR      reduce using rule 66 (operator -> expression PLUS expression .)
    BITWISE_XOR     reduce using rule 66 (operator -> expression PLUS expression .)
    URSHIFT         reduce using rule 66 (operator -> expression PLUS expression .)
    LSHIFT          reduce using rule 66 (operator -> expression PLUS expression .)
    RSHIFT          reduce using rule 66 (operator -> expression PLUS expression .)
    RPAREN          reduce using rule 66 (operator -> expression PLUS expression .)
    COMMA           reduce using rule 66 (operator -> expression PLUS expression .)
    RBRACKET        reduce using rule 66 (operator -> expression PLUS expression .)
    RCHAV           reduce using rule 66 (operator -> expression PLUS expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81

  ! TIMES           [ reduce using rule 66 (operator -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 66 (operator -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 66 (operator -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]
  ! URSHIFT         [ shift and go to state 96 ]
  ! LSHIFT          [ shift and go to state 97 ]
  ! RSHIFT          [ shift and go to state 98 ]

    operatorbittobit               shift and go to state 95

state 136

    (67) operator -> expression MINUS expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 67 (operator -> expression MINUS expression .)
    PLUS            reduce using rule 67 (operator -> expression MINUS expression .)
    MINUS           reduce using rule 67 (operator -> expression MINUS expression .)
    LEQ             reduce using rule 67 (operator -> expression MINUS expression .)
    GEQ             reduce using rule 67 (operator -> expression MINUS expression .)
    LT              reduce using rule 67 (operator -> expression MINUS expression .)
    GT              reduce using rule 67 (operator -> expression MINUS expression .)
    NEQ             reduce using rule 67 (operator -> expression MINUS expression .)
    EQ              reduce using rule 67 (operator -> expression MINUS expression .)
    AND             reduce using rule 67 (operator -> expression MINUS expression .)
    OR              reduce using rule 67 (operator -> expression MINUS expression .)
    BITWISE_AND     reduce using rule 67 (operator -> expression MINUS expression .)
    BITWISE_OR      reduce using rule 67 (operator -> expression MINUS expression .)
    BITWISE_XOR     reduce using rule 67 (operator -> expression MINUS expression .)
    URSHIFT         reduce using rule 67 (operator -> expression MINUS expression .)
    LSHIFT          reduce using rule 67 (operator -> expression MINUS expression .)
    RSHIFT          reduce using rule 67 (operator -> expression MINUS expression .)
    RPAREN          reduce using rule 67 (operator -> expression MINUS expression .)
    COMMA           reduce using rule 67 (operator -> expression MINUS expression .)
    RBRACKET        reduce using rule 67 (operator -> expression MINUS expression .)
    RCHAV           reduce using rule 67 (operator -> expression MINUS expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81

  ! TIMES           [ reduce using rule 67 (operator -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 67 (operator -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 67 (operator -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]
  ! URSHIFT         [ shift and go to state 96 ]
  ! LSHIFT          [ shift and go to state 97 ]
  ! RSHIFT          [ shift and go to state 98 ]

    operatorbittobit               shift and go to state 95

state 137

    (80) operator -> expression LEQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 80 (operator -> expression LEQ expression .)
    LEQ             reduce using rule 80 (operator -> expression LEQ expression .)
    GEQ             reduce using rule 80 (operator -> expression LEQ expression .)
    LT              reduce using rule 80 (operator -> expression LEQ expression .)
    GT              reduce using rule 80 (operator -> expression LEQ expression .)
    NEQ             reduce using rule 80 (operator -> expression LEQ expression .)
    EQ              reduce using rule 80 (operator -> expression LEQ expression .)
    AND             reduce using rule 80 (operator -> expression LEQ expression .)
    OR              reduce using rule 80 (operator -> expression LEQ expression .)
    BITWISE_AND     reduce using rule 80 (operator -> expression LEQ expression .)
    BITWISE_OR      reduce using rule 80 (operator -> expression LEQ expression .)
    BITWISE_XOR     reduce using rule 80 (operator -> expression LEQ expression .)
    RPAREN          reduce using rule 80 (operator -> expression LEQ expression .)
    COMMA           reduce using rule 80 (operator -> expression LEQ expression .)
    RBRACKET        reduce using rule 80 (operator -> expression LEQ expression .)
    RCHAV           reduce using rule 80 (operator -> expression LEQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! MODULE          [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! PLUS            [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! URSHIFT         [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! LSHIFT          [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! RSHIFT          [ reduce using rule 80 (operator -> expression LEQ expression .) ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 138

    (81) operator -> expression GEQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 81 (operator -> expression GEQ expression .)
    LEQ             reduce using rule 81 (operator -> expression GEQ expression .)
    GEQ             reduce using rule 81 (operator -> expression GEQ expression .)
    LT              reduce using rule 81 (operator -> expression GEQ expression .)
    GT              reduce using rule 81 (operator -> expression GEQ expression .)
    NEQ             reduce using rule 81 (operator -> expression GEQ expression .)
    EQ              reduce using rule 81 (operator -> expression GEQ expression .)
    AND             reduce using rule 81 (operator -> expression GEQ expression .)
    OR              reduce using rule 81 (operator -> expression GEQ expression .)
    BITWISE_AND     reduce using rule 81 (operator -> expression GEQ expression .)
    BITWISE_OR      reduce using rule 81 (operator -> expression GEQ expression .)
    BITWISE_XOR     reduce using rule 81 (operator -> expression GEQ expression .)
    RPAREN          reduce using rule 81 (operator -> expression GEQ expression .)
    COMMA           reduce using rule 81 (operator -> expression GEQ expression .)
    RBRACKET        reduce using rule 81 (operator -> expression GEQ expression .)
    RCHAV           reduce using rule 81 (operator -> expression GEQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! MODULE          [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! PLUS            [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! URSHIFT         [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! LSHIFT          [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! RSHIFT          [ reduce using rule 81 (operator -> expression GEQ expression .) ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 139

    (82) operator -> expression LT expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 82 (operator -> expression LT expression .)
    LEQ             reduce using rule 82 (operator -> expression LT expression .)
    GEQ             reduce using rule 82 (operator -> expression LT expression .)
    LT              reduce using rule 82 (operator -> expression LT expression .)
    GT              reduce using rule 82 (operator -> expression LT expression .)
    NEQ             reduce using rule 82 (operator -> expression LT expression .)
    EQ              reduce using rule 82 (operator -> expression LT expression .)
    AND             reduce using rule 82 (operator -> expression LT expression .)
    OR              reduce using rule 82 (operator -> expression LT expression .)
    BITWISE_AND     reduce using rule 82 (operator -> expression LT expression .)
    BITWISE_OR      reduce using rule 82 (operator -> expression LT expression .)
    BITWISE_XOR     reduce using rule 82 (operator -> expression LT expression .)
    RPAREN          reduce using rule 82 (operator -> expression LT expression .)
    COMMA           reduce using rule 82 (operator -> expression LT expression .)
    RBRACKET        reduce using rule 82 (operator -> expression LT expression .)
    RCHAV           reduce using rule 82 (operator -> expression LT expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! MODULE          [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! URSHIFT         [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! LSHIFT          [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! RSHIFT          [ reduce using rule 82 (operator -> expression LT expression .) ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 140

    (83) operator -> expression GT expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 83 (operator -> expression GT expression .)
    LEQ             reduce using rule 83 (operator -> expression GT expression .)
    GEQ             reduce using rule 83 (operator -> expression GT expression .)
    LT              reduce using rule 83 (operator -> expression GT expression .)
    GT              reduce using rule 83 (operator -> expression GT expression .)
    NEQ             reduce using rule 83 (operator -> expression GT expression .)
    EQ              reduce using rule 83 (operator -> expression GT expression .)
    AND             reduce using rule 83 (operator -> expression GT expression .)
    OR              reduce using rule 83 (operator -> expression GT expression .)
    BITWISE_AND     reduce using rule 83 (operator -> expression GT expression .)
    BITWISE_OR      reduce using rule 83 (operator -> expression GT expression .)
    BITWISE_XOR     reduce using rule 83 (operator -> expression GT expression .)
    RPAREN          reduce using rule 83 (operator -> expression GT expression .)
    COMMA           reduce using rule 83 (operator -> expression GT expression .)
    RBRACKET        reduce using rule 83 (operator -> expression GT expression .)
    RCHAV           reduce using rule 83 (operator -> expression GT expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! MODULE          [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! URSHIFT         [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! LSHIFT          [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! RSHIFT          [ reduce using rule 83 (operator -> expression GT expression .) ]
  ! LEQ             [ shift and go to state 84 ]
  ! GEQ             [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 87 ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 141

    (84) operator -> expression NEQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 84 (operator -> expression NEQ expression .)
    NEQ             reduce using rule 84 (operator -> expression NEQ expression .)
    EQ              reduce using rule 84 (operator -> expression NEQ expression .)
    AND             reduce using rule 84 (operator -> expression NEQ expression .)
    OR              reduce using rule 84 (operator -> expression NEQ expression .)
    BITWISE_AND     reduce using rule 84 (operator -> expression NEQ expression .)
    BITWISE_OR      reduce using rule 84 (operator -> expression NEQ expression .)
    BITWISE_XOR     reduce using rule 84 (operator -> expression NEQ expression .)
    RPAREN          reduce using rule 84 (operator -> expression NEQ expression .)
    COMMA           reduce using rule 84 (operator -> expression NEQ expression .)
    RBRACKET        reduce using rule 84 (operator -> expression NEQ expression .)
    RCHAV           reduce using rule 84 (operator -> expression NEQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! MODULE          [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! PLUS            [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! URSHIFT         [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! LSHIFT          [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! RSHIFT          [ reduce using rule 84 (operator -> expression NEQ expression .) ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 142

    (85) operator -> expression EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 85 (operator -> expression EQ expression .)
    NEQ             reduce using rule 85 (operator -> expression EQ expression .)
    EQ              reduce using rule 85 (operator -> expression EQ expression .)
    AND             reduce using rule 85 (operator -> expression EQ expression .)
    OR              reduce using rule 85 (operator -> expression EQ expression .)
    BITWISE_AND     reduce using rule 85 (operator -> expression EQ expression .)
    BITWISE_OR      reduce using rule 85 (operator -> expression EQ expression .)
    BITWISE_XOR     reduce using rule 85 (operator -> expression EQ expression .)
    RPAREN          reduce using rule 85 (operator -> expression EQ expression .)
    COMMA           reduce using rule 85 (operator -> expression EQ expression .)
    RBRACKET        reduce using rule 85 (operator -> expression EQ expression .)
    RCHAV           reduce using rule 85 (operator -> expression EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! MODULE          [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! PLUS            [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! LT              [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! GT              [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! URSHIFT         [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! LSHIFT          [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! RSHIFT          [ reduce using rule 85 (operator -> expression EQ expression .) ]
  ! NEQ             [ shift and go to state 88 ]
  ! EQ              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 143

    (86) operator -> expression AND expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 86 (operator -> expression AND expression .)
    AND             reduce using rule 86 (operator -> expression AND expression .)
    OR              reduce using rule 86 (operator -> expression AND expression .)
    RPAREN          reduce using rule 86 (operator -> expression AND expression .)
    COMMA           reduce using rule 86 (operator -> expression AND expression .)
    RBRACKET        reduce using rule 86 (operator -> expression AND expression .)
    RCHAV           reduce using rule 86 (operator -> expression AND expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! MODULE          [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! LT              [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! GT              [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! EQ              [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! BITWISE_AND     [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! BITWISE_OR      [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! BITWISE_XOR     [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! URSHIFT         [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! LSHIFT          [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! RSHIFT          [ reduce using rule 86 (operator -> expression AND expression .) ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]

    operatorbittobit               shift and go to state 95

state 144

    (87) operator -> expression OR expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 87 (operator -> expression OR expression .)
    OR              reduce using rule 87 (operator -> expression OR expression .)
    RPAREN          reduce using rule 87 (operator -> expression OR expression .)
    COMMA           reduce using rule 87 (operator -> expression OR expression .)
    RBRACKET        reduce using rule 87 (operator -> expression OR expression .)
    RCHAV           reduce using rule 87 (operator -> expression OR expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! MODULE          [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! LT              [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! GT              [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! EQ              [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! AND             [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! BITWISE_OR      [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! URSHIFT         [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! LSHIFT          [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! RSHIFT          [ reduce using rule 87 (operator -> expression OR expression .) ]
  ! OR              [ shift and go to state 91 ]

    operatorbittobit               shift and go to state 95

state 145

    (88) operator -> expression BITWISE_AND expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    AND             reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    OR              reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    BITWISE_AND     reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    BITWISE_OR      reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    BITWISE_XOR     reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    RPAREN          reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    COMMA           reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    RBRACKET        reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    RCHAV           reduce using rule 88 (operator -> expression BITWISE_AND expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! DIVIDE          [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! MODULE          [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! PLUS            [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! MINUS           [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! LEQ             [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! GEQ             [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! LT              [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! GT              [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! NEQ             [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! EQ              [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! URSHIFT         [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! LSHIFT          [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! RSHIFT          [ reduce using rule 88 (operator -> expression BITWISE_AND expression .) ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_AND     [ shift and go to state 92 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 146

    (89) operator -> expression BITWISE_OR expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    AND             reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    OR              reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    BITWISE_OR      reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    RPAREN          reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    COMMA           reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    RBRACKET        reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    RCHAV           reduce using rule 89 (operator -> expression BITWISE_OR expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    BITWISE_AND     shift and go to state 92
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! DIVIDE          [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! MODULE          [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! PLUS            [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! MINUS           [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! LEQ             [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! GEQ             [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! LT              [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! GT              [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! NEQ             [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! EQ              [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! URSHIFT         [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! LSHIFT          [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! RSHIFT          [ reduce using rule 89 (operator -> expression BITWISE_OR expression .) ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_OR      [ shift and go to state 93 ]

    operatorbittobit               shift and go to state 95

state 147

    (90) operator -> expression BITWISE_XOR expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    AND             reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    OR              reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    BITWISE_OR      reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    BITWISE_XOR     reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    RPAREN          reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    COMMA           reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    RBRACKET        reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    RCHAV           reduce using rule 90 (operator -> expression BITWISE_XOR expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    BITWISE_AND     shift and go to state 92
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! DIVIDE          [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! MODULE          [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! PLUS            [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! MINUS           [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! LEQ             [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! GEQ             [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! LT              [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! GT              [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! NEQ             [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! EQ              [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! BITWISE_AND     [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! URSHIFT         [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! LSHIFT          [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! RSHIFT          [ reduce using rule 90 (operator -> expression BITWISE_XOR expression .) ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! BITWISE_OR      [ shift and go to state 93 ]
  ! BITWISE_XOR     [ shift and go to state 94 ]

    operatorbittobit               shift and go to state 95

state 148

    (33) stm -> WHILE LPAREN expression . RPAREN bodyorstm
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 180
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 149

    (34) stm -> DO bodyorstm WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 181


state 150

    (35) stm -> FOR LPAREN expression_for . SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    SEMICOLON       shift and go to state 182


state 151

    (52) expression_for -> type . ID EQUAL expression

    ID              shift and go to state 183


state 152

    (53) expression_for -> ID . EQUAL expression

    EQUAL           shift and go to state 184


state 153

    (36) stm -> IF LPAREN expression . RPAREN bodyorstm
    (37) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE bodyorstm
    (38) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE IF bodyorstm
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 185
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 154

    (40) stm -> atributemodifier type ID . SEMICOLON
    (41) stm -> atributemodifier type ID . EQUAL expression SEMICOLON
    (42) stm -> atributemodifier type ID . LBRACKET RBRACKET SEMICOLON
    (45) stm -> atributemodifier type ID . LBRACKET RBRACKET EQUAL expression SEMICOLON
    (46) stm -> atributemodifier type ID . LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 186
    EQUAL           shift and go to state 187
    LBRACKET        shift and go to state 188


state 155

    (43) stm -> atributemodifier type LBRACKET . RBRACKET ID SEMICOLON
    (44) stm -> atributemodifier type LBRACKET . RBRACKET ID EQUAL chav_exp SEMICOLON
    (47) stm -> atributemodifier type LBRACKET . RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> atributemodifier type LBRACKET . RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 189


state 156

    (68) operator -> ID EQUAL expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 68 (operator -> ID EQUAL expression .)
    RPAREN          reduce using rule 68 (operator -> ID EQUAL expression .)
    COMMA           reduce using rule 68 (operator -> ID EQUAL expression .)
    RBRACKET        reduce using rule 68 (operator -> ID EQUAL expression .)
    RCHAV           reduce using rule 68 (operator -> ID EQUAL expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! MODULE          [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! PLUS            [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! MINUS           [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! LEQ             [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! GEQ             [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! LT              [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! GT              [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! NEQ             [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! EQ              [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! AND             [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! OR              [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! BITWISE_AND     [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! BITWISE_OR      [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! BITWISE_XOR     [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! URSHIFT         [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 68 (operator -> ID EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 68 (operator -> ID EQUAL expression .) ]

    operatorbittobit               shift and go to state 95

state 157

    (69) operator -> ID MINUS_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 69 (operator -> ID MINUS_EQ expression .)
    RPAREN          reduce using rule 69 (operator -> ID MINUS_EQ expression .)
    COMMA           reduce using rule 69 (operator -> ID MINUS_EQ expression .)
    RBRACKET        reduce using rule 69 (operator -> ID MINUS_EQ expression .)
    RCHAV           reduce using rule 69 (operator -> ID MINUS_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! LT              [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! GT              [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! EQ              [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! AND             [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! OR              [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 69 (operator -> ID MINUS_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 158

    (70) operator -> ID TIMES_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 70 (operator -> ID TIMES_EQ expression .)
    RPAREN          reduce using rule 70 (operator -> ID TIMES_EQ expression .)
    COMMA           reduce using rule 70 (operator -> ID TIMES_EQ expression .)
    RBRACKET        reduce using rule 70 (operator -> ID TIMES_EQ expression .)
    RCHAV           reduce using rule 70 (operator -> ID TIMES_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! MODULE          [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! PLUS            [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! MINUS           [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! LEQ             [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! GEQ             [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! LT              [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! GT              [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! NEQ             [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! EQ              [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! AND             [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! OR              [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 70 (operator -> ID TIMES_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 159

    (71) operator -> ID PLUS_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 71 (operator -> ID PLUS_EQ expression .)
    RPAREN          reduce using rule 71 (operator -> ID PLUS_EQ expression .)
    COMMA           reduce using rule 71 (operator -> ID PLUS_EQ expression .)
    RBRACKET        reduce using rule 71 (operator -> ID PLUS_EQ expression .)
    RCHAV           reduce using rule 71 (operator -> ID PLUS_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! LT              [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! GT              [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! EQ              [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! AND             [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! OR              [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 71 (operator -> ID PLUS_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 160

    (72) operator -> ID DIVIDE_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 72 (operator -> ID DIVIDE_EQ expression .)
    RPAREN          reduce using rule 72 (operator -> ID DIVIDE_EQ expression .)
    COMMA           reduce using rule 72 (operator -> ID DIVIDE_EQ expression .)
    RBRACKET        reduce using rule 72 (operator -> ID DIVIDE_EQ expression .)
    RCHAV           reduce using rule 72 (operator -> ID DIVIDE_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! MODULE          [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! PLUS            [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! MINUS           [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! LEQ             [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! GEQ             [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! LT              [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! GT              [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! NEQ             [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! EQ              [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! AND             [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! OR              [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 72 (operator -> ID DIVIDE_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 161

    (73) operator -> ID MOD_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 73 (operator -> ID MOD_EQ expression .)
    RPAREN          reduce using rule 73 (operator -> ID MOD_EQ expression .)
    COMMA           reduce using rule 73 (operator -> ID MOD_EQ expression .)
    RBRACKET        reduce using rule 73 (operator -> ID MOD_EQ expression .)
    RCHAV           reduce using rule 73 (operator -> ID MOD_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! MODULE          [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! PLUS            [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! MINUS           [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! LEQ             [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! GEQ             [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! LT              [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! GT              [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! NEQ             [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! EQ              [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! AND             [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! OR              [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 73 (operator -> ID MOD_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 162

    (74) operator -> ID BITWISE_AND_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .)
    RPAREN          reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .)
    COMMA           reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .)
    RBRACKET        reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .)
    RCHAV           reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MODULE          [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! PLUS            [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MINUS           [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LEQ             [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GEQ             [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LT              [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GT              [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! NEQ             [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! EQ              [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! AND             [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! OR              [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 74 (operator -> ID BITWISE_AND_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 163

    (75) operator -> ID BITWISE_OR_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .)
    RPAREN          reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .)
    COMMA           reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .)
    RBRACKET        reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .)
    RCHAV           reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MODULE          [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! PLUS            [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MINUS           [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LEQ             [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GEQ             [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LT              [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GT              [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! NEQ             [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! EQ              [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! AND             [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! OR              [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 75 (operator -> ID BITWISE_OR_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 164

    (76) operator -> ID BITWISE_XOR_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .)
    RPAREN          reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .)
    COMMA           reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .)
    RBRACKET        reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .)
    RCHAV           reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MODULE          [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! PLUS            [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MINUS           [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LEQ             [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GEQ             [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LT              [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GT              [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! NEQ             [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! EQ              [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! AND             [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! OR              [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 76 (operator -> ID BITWISE_XOR_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 165

    (77) operator -> ID URSHIFT_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 77 (operator -> ID URSHIFT_EQ expression .)
    RPAREN          reduce using rule 77 (operator -> ID URSHIFT_EQ expression .)
    COMMA           reduce using rule 77 (operator -> ID URSHIFT_EQ expression .)
    RBRACKET        reduce using rule 77 (operator -> ID URSHIFT_EQ expression .)
    RCHAV           reduce using rule 77 (operator -> ID URSHIFT_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 77 (operator -> ID URSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 166

    (78) operator -> ID LSHIFT_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 78 (operator -> ID LSHIFT_EQ expression .)
    RPAREN          reduce using rule 78 (operator -> ID LSHIFT_EQ expression .)
    COMMA           reduce using rule 78 (operator -> ID LSHIFT_EQ expression .)
    RBRACKET        reduce using rule 78 (operator -> ID LSHIFT_EQ expression .)
    RCHAV           reduce using rule 78 (operator -> ID LSHIFT_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 78 (operator -> ID LSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 167

    (79) operator -> ID RSHIFT_EQ expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 79 (operator -> ID RSHIFT_EQ expression .)
    RPAREN          reduce using rule 79 (operator -> ID RSHIFT_EQ expression .)
    COMMA           reduce using rule 79 (operator -> ID RSHIFT_EQ expression .)
    RBRACKET        reduce using rule 79 (operator -> ID RSHIFT_EQ expression .)
    RCHAV           reduce using rule 79 (operator -> ID RSHIFT_EQ expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

  ! TIMES           [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 79 (operator -> ID RSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 95

state 168

    (117) call -> ID LPAREN params_call . RPAREN

    RPAREN          shift and go to state 190


state 169

    (118) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 118 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 118 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 118 (call -> ID LPAREN RPAREN .)
    MODULE          reduce using rule 118 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 118 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 118 (call -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 118 (call -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 118 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 118 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 118 (call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 118 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 118 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 118 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 118 (call -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 118 (call -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 118 (call -> ID LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 118 (call -> ID LPAREN RPAREN .)
    URSHIFT         reduce using rule 118 (call -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 118 (call -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 118 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 118 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 118 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 118 (call -> ID LPAREN RPAREN .)
    RCHAV           reduce using rule 118 (call -> ID LPAREN RPAREN .)


state 170

    (119) params_call -> expression . COMMA params_call
    (120) params_call -> expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 191
    RPAREN          reduce using rule 120 (params_call -> expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 171

    (49) stm -> RETURN expression SEMICOLON .

    WHILE           reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    DO              reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    IF              reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    INT_NUMBER      reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    ID              reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    STATIC          reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    FINAL           reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    INCREMENT       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    DECREMENT       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    PLUS            reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_INT        reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_LONG       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    TYPE_VOID       reduce using rule 49 (stm -> RETURN expression SEMICOLON .)
    RCHAV           reduce using rule 49 (stm -> RETURN expression SEMICOLON .)


state 172

    (61) expression -> NEW type LPAREN . params_call RPAREN
    (119) params_call -> . expression COMMA params_call
    (120) params_call -> . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    params_call                    shift and go to state 192
    expression                     shift and go to state 170
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 173

    (62) expression -> NEW type LBRACKET . expression RBRACKET
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 193
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 174

    (20) atribute -> visibility atributemodifier type ID EQUAL expression . SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 194
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 175

    (27) sigparams -> type . ID
    (28) sigparams -> type . ID COMMA sigparams

    ID              shift and go to state 195


state 176

    (25) signature -> visibility atributemodifier type ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 196


state 177

    (26) signature -> visibility atributemodifier type brackets_expression ID LPAREN . sigparams RPAREN
    (27) sigparams -> . type ID
    (28) sigparams -> . type ID COMMA sigparams
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 175
    sigparams                      shift and go to state 197
    primitivetypes                 shift and go to state 37

state 178

    (105) brackets_expression -> LBRACKET INT_NUMBER RBRACKET .

    ID              reduce using rule 105 (brackets_expression -> LBRACKET INT_NUMBER RBRACKET .)


state 179

    (106) brackets_expression -> LBRACKET ID RBRACKET .

    ID              reduce using rule 106 (brackets_expression -> LBRACKET ID RBRACKET .)


state 180

    (33) stm -> WHILE LPAREN expression RPAREN . bodyorstm
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 198
    body                           shift and go to state 101

state 181

    (34) stm -> DO bodyorstm WHILE LPAREN . expression RPAREN SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 199
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 182

    (35) stm -> FOR LPAREN expression_for SEMICOLON . expression SEMICOLON expression RPAREN bodyorstm
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 200
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 183

    (52) expression_for -> type ID . EQUAL expression

    EQUAL           shift and go to state 201


state 184

    (53) expression_for -> ID EQUAL . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 202
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 185

    (36) stm -> IF LPAREN expression RPAREN . bodyorstm
    (37) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE bodyorstm
    (38) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE IF bodyorstm
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 203
    body                           shift and go to state 101

state 186

    (40) stm -> atributemodifier type ID SEMICOLON .

    WHILE           reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    DO              reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    FOR             reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    IF              reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    SEMICOLON       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    RETURN          reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    INT_NUMBER      reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    STRING          reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    ID              reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    NEW             reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    INCREMENT       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    DECREMENT       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    MINUS           reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    PLUS            reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    NOT             reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 40 (stm -> atributemodifier type ID SEMICOLON .)


state 187

    (41) stm -> atributemodifier type ID EQUAL . expression SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 204
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 188

    (42) stm -> atributemodifier type ID LBRACKET . RBRACKET SEMICOLON
    (45) stm -> atributemodifier type ID LBRACKET . RBRACKET EQUAL expression SEMICOLON
    (46) stm -> atributemodifier type ID LBRACKET . RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 205


state 189

    (43) stm -> atributemodifier type LBRACKET RBRACKET . ID SEMICOLON
    (44) stm -> atributemodifier type LBRACKET RBRACKET . ID EQUAL chav_exp SEMICOLON
    (47) stm -> atributemodifier type LBRACKET RBRACKET . ID LBRACKET RBRACKET SEMICOLON
    (48) stm -> atributemodifier type LBRACKET RBRACKET . ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    ID              shift and go to state 206


state 190

    (117) call -> ID LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    TIMES           reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    MODULE          reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    PLUS            reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    MINUS           reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    LEQ             reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    GEQ             reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    LT              reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    GT              reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    NEQ             reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    EQ              reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    AND             reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    OR              reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    COMMA           reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)
    RCHAV           reduce using rule 117 (call -> ID LPAREN params_call RPAREN .)


state 191

    (119) params_call -> expression COMMA . params_call
    (119) params_call -> . expression COMMA params_call
    (120) params_call -> . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 170
    params_call                    shift and go to state 207
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 192

    (61) expression -> NEW type LPAREN params_call . RPAREN

    RPAREN          shift and go to state 208


state 193

    (62) expression -> NEW type LBRACKET expression . RBRACKET
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    RBRACKET        shift and go to state 209
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 194

    (20) atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .

    PUBLIC          reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PRIVATE         reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PROTECTED       reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 20 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)


state 195

    (27) sigparams -> type ID .
    (28) sigparams -> type ID . COMMA sigparams

    RPAREN          reduce using rule 27 (sigparams -> type ID .)
    COMMA           shift and go to state 210


state 196

    (25) signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 25 (signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .)


state 197

    (26) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 211


state 198

    (33) stm -> WHILE LPAREN expression RPAREN bodyorstm .

    WHILE           reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 33 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)


state 199

    (34) stm -> DO bodyorstm WHILE LPAREN expression . RPAREN SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 212
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 200

    (35) stm -> FOR LPAREN expression_for SEMICOLON expression . SEMICOLON expression RPAREN bodyorstm
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 213
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 201

    (52) expression_for -> type ID EQUAL . expression
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 214
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 202

    (53) expression_for -> ID EQUAL expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 53 (expression_for -> ID EQUAL expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 203

    (36) stm -> IF LPAREN expression RPAREN bodyorstm .
    (37) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE bodyorstm
    (38) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE IF bodyorstm

    WHILE           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ELSE            shift and go to state 215


state 204

    (41) stm -> atributemodifier type ID EQUAL expression . SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 216
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 205

    (42) stm -> atributemodifier type ID LBRACKET RBRACKET . SEMICOLON
    (45) stm -> atributemodifier type ID LBRACKET RBRACKET . EQUAL expression SEMICOLON
    (46) stm -> atributemodifier type ID LBRACKET RBRACKET . EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 217
    EQUAL           shift and go to state 218


state 206

    (43) stm -> atributemodifier type LBRACKET RBRACKET ID . SEMICOLON
    (44) stm -> atributemodifier type LBRACKET RBRACKET ID . EQUAL chav_exp SEMICOLON
    (47) stm -> atributemodifier type LBRACKET RBRACKET ID . LBRACKET RBRACKET SEMICOLON
    (48) stm -> atributemodifier type LBRACKET RBRACKET ID . LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 220
    EQUAL           shift and go to state 221
    LBRACKET        shift and go to state 219


state 207

    (119) params_call -> expression COMMA params_call .

    RPAREN          reduce using rule 119 (params_call -> expression COMMA params_call .)


state 208

    (61) expression -> NEW type LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    TIMES           reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    MODULE          reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    PLUS            reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    MINUS           reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    LEQ             reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    GEQ             reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    LT              reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    GT              reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    NEQ             reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    EQ              reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    AND             reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    OR              reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    COMMA           reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)
    RCHAV           reduce using rule 61 (expression -> NEW type LPAREN params_call RPAREN .)


state 209

    (62) expression -> NEW type LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    MODULE          reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    LEQ             reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    GEQ             reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    LT              reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    GT              reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    EQ              reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    AND             reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    OR              reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_AND     reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_OR      reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_XOR     reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    URSHIFT         reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)
    RCHAV           reduce using rule 62 (expression -> NEW type LBRACKET expression RBRACKET .)


state 210

    (28) sigparams -> type ID COMMA . sigparams
    (27) sigparams -> . type ID
    (28) sigparams -> . type ID COMMA sigparams
    (107) type -> . primitivetypes
    (108) primitivetypes -> . TYPE_INT
    (109) primitivetypes -> . TYPE_FLOAT
    (110) primitivetypes -> . TYPE_DOUBLE
    (111) primitivetypes -> . TYPE_BYTE
    (112) primitivetypes -> . TYPE_BOOLEAN
    (113) primitivetypes -> . TYPE_CHAR
    (114) primitivetypes -> . TYPE_STRING
    (115) primitivetypes -> . TYPE_LONG
    (116) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_DOUBLE     shift and go to state 40
    TYPE_BYTE       shift and go to state 41
    TYPE_BOOLEAN    shift and go to state 42
    TYPE_CHAR       shift and go to state 43
    TYPE_STRING     shift and go to state 44
    TYPE_LONG       shift and go to state 45
    TYPE_VOID       shift and go to state 46

    type                           shift and go to state 175
    sigparams                      shift and go to state 222
    primitivetypes                 shift and go to state 37

state 211

    (26) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 26 (signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .)


state 212

    (34) stm -> DO bodyorstm WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 223


state 213

    (35) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON . expression RPAREN bodyorstm
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 224
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 214

    (52) expression_for -> type ID EQUAL expression .
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 52 (expression_for -> type ID EQUAL expression .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 215

    (37) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . bodyorstm
    (38) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . IF bodyorstm
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    IF              shift and go to state 225
    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 226
    body                           shift and go to state 101

state 216

    (41) stm -> atributemodifier type ID EQUAL expression SEMICOLON .

    WHILE           reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DO              reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FOR             reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INT_NUMBER      reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STRING          reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NEW             reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INCREMENT       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DECREMENT       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    MINUS           reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    PLUS            reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NOT             reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 41 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)


state 217

    (42) stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .

    WHILE           reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DO              reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    INT_NUMBER      reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    NEW             reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    STATIC          reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    MINUS           reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    PLUS            reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    NOT             reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_INT        reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_FLOAT      reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BYTE       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_CHAR       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_STRING     reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_LONG       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_VOID       reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    RCHAV           reduce using rule 42 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)


state 218

    (45) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL . expression SEMICOLON
    (46) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL . chav_exp SEMICOLON
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (121) chav_exp -> . LCHAV RCHAV
    (122) chav_exp -> . LCHAV expression_chav
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    LCHAV           shift and go to state 229
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 227
    chav_exp                       shift and go to state 228
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 219

    (47) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET . RBRACKET SEMICOLON
    (48) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET . RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 230


state 220

    (43) stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .

    WHILE           reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DO              reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FOR             reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    IF              reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    SEMICOLON       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    RETURN          reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    INT_NUMBER      reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    STRING          reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    ID              reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    NEW             reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    STATIC          reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FINAL           reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    INCREMENT       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DECREMENT       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    MINUS           reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    PLUS            reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    NOT             reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_INT        reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_STRING     reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_LONG       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_VOID       reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    RCHAV           reduce using rule 43 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)


state 221

    (44) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL . chav_exp SEMICOLON
    (121) chav_exp -> . LCHAV RCHAV
    (122) chav_exp -> . LCHAV expression_chav

    LCHAV           shift and go to state 229

    chav_exp                       shift and go to state 231

state 222

    (28) sigparams -> type ID COMMA sigparams .

    RPAREN          reduce using rule 28 (sigparams -> type ID COMMA sigparams .)


state 223

    (34) stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .

    WHILE           reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INT_NUMBER      reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NEW             reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STATIC          reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_INT        reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BYTE       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_LONG       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_VOID       reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RCHAV           reduce using rule 34 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)


state 224

    (35) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression . RPAREN bodyorstm
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 232
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 225

    (38) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF . bodyorstm
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 233
    body                           shift and go to state 101

state 226

    (37) stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .

    WHILE           reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DO              reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FOR             reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    IF              reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    SEMICOLON       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RETURN          reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FLOAT_NUMBER    reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INT_NUMBER      reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STRING          reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    ID              reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NEW             reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STATIC          reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FINAL           reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INCREMENT       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DECREMENT       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    MINUS           reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    PLUS            reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NOT             reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_INT        reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_FLOAT      reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_DOUBLE     reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BYTE       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_CHAR       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_STRING     reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_LONG       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_VOID       reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RCHAV           reduce using rule 37 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)


state 227

    (45) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression . SEMICOLON
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 234
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 228

    (46) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 235


state 229

    (121) chav_exp -> LCHAV . RCHAV
    (122) chav_exp -> LCHAV . expression_chav
    (123) expression_chav -> . expression COMMA expression_chav
    (124) expression_chav -> . expression RCHAV
    (125) expression_chav -> . expression COMMA RCHAV
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    RCHAV           shift and go to state 236
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression_chav                shift and go to state 237
    expression                     shift and go to state 238
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 230

    (47) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET . SEMICOLON
    (48) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET . EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 239
    EQUAL           shift and go to state 240


state 231

    (44) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 241


state 232

    (35) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN . bodyorstm
    (51) bodyorstm -> . body
    (29) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 33

    bodyorstm                      shift and go to state 242
    body                           shift and go to state 101

state 233

    (38) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .

    WHILE           reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DO              reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FOR             reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    IF              reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    SEMICOLON       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RETURN          reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FLOAT_NUMBER    reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INT_NUMBER      reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STRING          reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    ID              reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NEW             reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STATIC          reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FINAL           reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INCREMENT       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DECREMENT       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    MINUS           reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    PLUS            reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NOT             reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_INT        reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_FLOAT      reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_DOUBLE     reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BYTE       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_CHAR       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_STRING     reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_LONG       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_VOID       reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RCHAV           reduce using rule 38 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)


state 234

    (45) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .

    WHILE           reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DO              reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FOR             reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    IF              reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    INT_NUMBER      reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    STRING          reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    ID              reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    NEW             reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    INCREMENT       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DECREMENT       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    MINUS           reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    PLUS            reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    NOT             reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 45 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)


state 235

    (46) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 46 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)


state 236

    (121) chav_exp -> LCHAV RCHAV .

    SEMICOLON       reduce using rule 121 (chav_exp -> LCHAV RCHAV .)


state 237

    (122) chav_exp -> LCHAV expression_chav .

    SEMICOLON       reduce using rule 122 (chav_exp -> LCHAV expression_chav .)


state 238

    (123) expression_chav -> expression . COMMA expression_chav
    (124) expression_chav -> expression . RCHAV
    (125) expression_chav -> expression . COMMA RCHAV
    (63) operator -> expression . TIMES expression
    (64) operator -> expression . DIVIDE expression
    (65) operator -> expression . MODULE expression
    (66) operator -> expression . PLUS expression
    (67) operator -> expression . MINUS expression
    (80) operator -> expression . LEQ expression
    (81) operator -> expression . GEQ expression
    (82) operator -> expression . LT expression
    (83) operator -> expression . GT expression
    (84) operator -> expression . NEQ expression
    (85) operator -> expression . EQ expression
    (86) operator -> expression . AND expression
    (87) operator -> expression . OR expression
    (88) operator -> expression . BITWISE_AND expression
    (89) operator -> expression . BITWISE_OR expression
    (90) operator -> expression . BITWISE_XOR expression
    (93) operator -> expression . operatorbittobit
    (101) operatorbittobit -> . URSHIFT
    (102) operatorbittobit -> . LSHIFT
    (103) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 243
    RCHAV           shift and go to state 244
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80
    MODULE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    LEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NEQ             shift and go to state 88
    EQ              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    URSHIFT         shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98

    operatorbittobit               shift and go to state 95

state 239

    (47) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .

    WHILE           reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DO              reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    INT_NUMBER      reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    NEW             reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    STATIC          reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    MINUS           reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    PLUS            reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    NOT             reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_INT        reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_FLOAT      reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BYTE       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_CHAR       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_STRING     reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_LONG       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_VOID       reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    RCHAV           reduce using rule 47 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)


state 240

    (48) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL . chav_exp SEMICOLON
    (121) chav_exp -> . LCHAV RCHAV
    (122) chav_exp -> . LCHAV expression_chav

    LCHAV           shift and go to state 229

    chav_exp                       shift and go to state 245

state 241

    (44) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 44 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)


state 242

    (35) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .

    WHILE           reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DO              reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FOR             reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    IF              reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RETURN          reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STRING          reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    ID              reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NEW             reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STATIC          reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FINAL           reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    MINUS           reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    PLUS            reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NOT             reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 35 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)


state 243

    (123) expression_chav -> expression COMMA . expression_chav
    (125) expression_chav -> expression COMMA . RCHAV
    (123) expression_chav -> . expression COMMA expression_chav
    (124) expression_chav -> . expression RCHAV
    (125) expression_chav -> . expression COMMA RCHAV
    (54) expression -> . operator
    (55) expression -> . call
    (56) expression -> . FLOAT_NUMBER
    (57) expression -> . DOUBLE_NUMBER
    (58) expression -> . INT_NUMBER
    (59) expression -> . STRING
    (60) expression -> . ID
    (61) expression -> . NEW type LPAREN params_call RPAREN
    (62) expression -> . NEW type LBRACKET expression RBRACKET
    (63) operator -> . expression TIMES expression
    (64) operator -> . expression DIVIDE expression
    (65) operator -> . expression MODULE expression
    (66) operator -> . expression PLUS expression
    (67) operator -> . expression MINUS expression
    (68) operator -> . ID EQUAL expression
    (69) operator -> . ID MINUS_EQ expression
    (70) operator -> . ID TIMES_EQ expression
    (71) operator -> . ID PLUS_EQ expression
    (72) operator -> . ID DIVIDE_EQ expression
    (73) operator -> . ID MOD_EQ expression
    (74) operator -> . ID BITWISE_AND_EQ expression
    (75) operator -> . ID BITWISE_OR_EQ expression
    (76) operator -> . ID BITWISE_XOR_EQ expression
    (77) operator -> . ID URSHIFT_EQ expression
    (78) operator -> . ID LSHIFT_EQ expression
    (79) operator -> . ID RSHIFT_EQ expression
    (80) operator -> . expression LEQ expression
    (81) operator -> . expression GEQ expression
    (82) operator -> . expression LT expression
    (83) operator -> . expression GT expression
    (84) operator -> . expression NEQ expression
    (85) operator -> . expression EQ expression
    (86) operator -> . expression AND expression
    (87) operator -> . expression OR expression
    (88) operator -> . expression BITWISE_AND expression
    (89) operator -> . expression BITWISE_OR expression
    (90) operator -> . expression BITWISE_XOR expression
    (91) operator -> . unaryoperatorprefx ID
    (92) operator -> . ID unaryoperatorsufx
    (93) operator -> . expression operatorbittobit
    (117) call -> . ID LPAREN params_call RPAREN
    (118) call -> . ID LPAREN RPAREN
    (94) unaryoperatorprefx -> . INCREMENT
    (95) unaryoperatorprefx -> . DECREMENT
    (96) unaryoperatorprefx -> . MINUS
    (97) unaryoperatorprefx -> . PLUS
    (98) unaryoperatorprefx -> . NOT

    RCHAV           shift and go to state 247
    FLOAT_NUMBER    shift and go to state 60
    DOUBLE_NUMBER   shift and go to state 61
    INT_NUMBER      shift and go to state 62
    STRING          shift and go to state 63
    ID              shift and go to state 56
    NEW             shift and go to state 64
    INCREMENT       shift and go to state 68
    DECREMENT       shift and go to state 69
    MINUS           shift and go to state 66
    PLUS            shift and go to state 65
    NOT             shift and go to state 70

    expression                     shift and go to state 238
    expression_chav                shift and go to state 246
    operator                       shift and go to state 58
    call                           shift and go to state 59
    unaryoperatorprefx             shift and go to state 67

state 244

    (124) expression_chav -> expression RCHAV .

    SEMICOLON       reduce using rule 124 (expression_chav -> expression RCHAV .)


state 245

    (48) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 248


state 246

    (123) expression_chav -> expression COMMA expression_chav .

    SEMICOLON       reduce using rule 123 (expression_chav -> expression COMMA expression_chav .)


state 247

    (125) expression_chav -> expression COMMA RCHAV .

    SEMICOLON       reduce using rule 125 (expression_chav -> expression COMMA RCHAV .)


state 248

    (48) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 48 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)

